---
title: PAT-A 1097 Deduplication on a Linked List (25)
urlname: pat-a-1097
date: 2020-07-08 23:34:31
toc: true
categories:
    - Note
    - Problem
tags:
    - PAT
    - Linked List
---

{% raw %}<article class="message is-success"><div class="message-body">{% endraw %}
<span class="icon"><i class="fa fa-check mr-2"></i></span>&nbsp;&nbsp;链表操作。出现段错误。
{% raw %}</div></article>{% endraw %}

Given a singly linked list L with integer keys, you are supposed to remove the nodes with duplicated absolute values of the keys. That is, for each value K, only the first node of which the value or absolute value of its key equals K will be kept. At the mean time, all the removed nodes must be kept in a separate list. For example, given L being 21 → -15 → -15 → -7 → 15, you must output 21 → -15 → -7, and the removed list -15 → 15.

<!--more-->

**Problem:**&nbsp;[PAT-A 1097 Deduplication on a Linked List](https://pintia.cn/problem-sets/994805342720868352/problems/994805369774129152 "PAT-A 1097 Deduplication on a Linked List")

## Input Specification

Each input file contains one test case. For each case, the first line contains the address of the first node, and a positive N (≤ 10^5) which is the total number of nodes. The address of a node is a 5-digit nonnegative integer, and NULL is represented by −1.

Then N lines follow, each describes a node in the format:

> Address **Key** **Next**

where `Address` is the position of the node, `Key` is an integer of which absolute value is no more than 10^4, and `Next` is the position of the next node.

## Output Specification

For each case, output the resulting linked list first, then the removed list. Each node occupies a line, and is printed in the same format as in the input.

## Sample

**Input**
```
00100 5
99999 -7 87654
23854 -15 00000
87654 15 -1
00000 -15 99999
00100 21 23854
```

**Output**
```
00100 21 23854
23854 -15 99999
99999 -7 -1
00000 -15 87654
87654 15 -1
```

## Analysis

&emsp;&emsp;题目大意：给一个链表，删除链表中绝对值相同的元素，并将删除的元素按照删除顺序组成新的链表。输出处理过的原链表和生成的删除链表。

&emsp;&emsp;简单的链表操作，注意输出为 5 位数字，左侧不足 5 位需要补零，另外要判断 -1 的输出。测试点中存在删除链表为空的数据，因此访问和输出删除链表时需要判断，否则会出现段错误。具体见代码

## Code

``` cpp
#include <bits/stdc++.h>
using namespace std;

struct Node {
    int key, nxt;
};

map<int, Node> mp;
map<int, int> vis;

void print_ll(int cur) {
    while (cur != -1) {
        printf("%05d %d ", cur, mp[cur].key);
        if (mp[cur].nxt == -1) {
            printf("-1\n");
        } else {
            printf("%05d\n",  mp[cur].nxt);
        }
        cur = mp[cur].nxt;
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int head, N;
    cin >> head >> N;
    for (int i = 0; i < N; i++) {
        Node nd;
        int addr;
        cin >> addr >> nd.key >> nd.nxt;
        mp[addr] = nd;
    }
    int res = head, rem_head = -1;
    Node *res_pre = &mp[head], *rem_pre = NULL;
    while (res != -1) {
        int tmp = mp[res].nxt;
        if (vis[abs(mp[res].key)]) {
            if (rem_head == -1) {
                rem_head = res;
            } else {
                rem_pre->nxt = res;
            }
            rem_pre = &mp[res];
        } else {
            vis[abs(mp[res].key)]++;
            res_pre->nxt = res;
            res_pre = &mp[res];
        }
        res = tmp;
    }

    // 处理链表末尾
    res_pre->nxt = -1;
    // 如果删除表为空则不访问, 否则出现段错误
    if (rem_pre != NULL) rem_pre->nxt = -1;

    print_ll(head);
    print_ll(rem_head);
}
```

## Tsukkomi

&emsp;&emsp;没什么好吐槽的，早睡护肝儿。