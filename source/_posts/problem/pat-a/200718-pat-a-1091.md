---
title: PAT-A 1091 Acute Stroke (30)
urlname: pat-a-1091
date: 2020-07-18 23:37:02
toc: true
categories:
    - Note
    - Problem
tags:
    - PAT
    - BFS
---

{% raw %}<article class="message is-success"><div class="message-body">{% endraw %}
<span class="icon"><i class="fa fa-check mr-2"></i></span>&nbsp;&nbsp;BFS 广度优先搜索。
{% raw %}</div></article>{% endraw %}

One important factor to identify acute stroke (急性脑卒中) is the volume of the stroke core. Given the results of image analysis in which the core regions are identified in each MRI slice, your job is to calculate the volume of the stroke core.

<!--more-->

**Problem:**&nbsp;[PAT-A 1091 Acute Stroke](https://pintia.cn/problem-sets/994805342720868352/problems/994805375457411072 "PAT-A 1091 Acute Stroke")

## Input Specification

Each input file contains one test case. For each case, the first line contains 4 positive integers: $M$, $N$, $L$ and $T$, where $M$ and $N$ are the sizes of each slice (i.e. pixels of a slice are in an $M×N$ matrix, and the maximum resolution is 1286 by 128); $L(≤60)$ is the number of slices of a brain; and $T$ is the integer threshold (i.e. if the volume of a connected core is less than $T$, then that core must not be counted).

Then $L$ slices are given. Each slice is represented by an $M×N$ matrix of 0's and 1's, where 1 represents a pixel of stroke, and 0 means normal. Since the thickness of a slice is a constant, we only have to count the number of 1's to obtain the volume. However, there might be several separated core regions in a brain, and only those with their volumes no less than $T$ are counted. Two pixels are **connected** and hence belong to the same region if they share a common side, as shown by Figure 1 where all the 6 red pixels are connected to the blue one.

{% raw %}<div align="center">{% endraw %}
![Figure 1](https://cdn.jsdelivr.net/gh/kainzhang/kz-img/blog/20/07/15/f85c00cc-62ce-41ff-8dd0-d1c288d87409.jpg)
{% raw %}</div>{% endraw %}


## Output Specification

For each case, output in a line the total volume of the stroke core.

## Sample

### Input

```
3 4 5 2
1 1 1 1
1 1 1 1
1 1 1 1
0 0 1 1
0 0 1 1
0 0 1 1
1 0 1 1
0 1 0 0
0 0 0 0
1 0 1 1
0 0 0 0
0 0 0 0
0 0 0 1
0 0 0 1
1 0 0 0
```

### Output

```
26
```

## Analysis

&emsp;&emsp;题目大意：按照上面图示的连接方式，在三维数组里搜索 1 的数量。其中 1 数量大于等于 $T$ 的区域被认为是 stroke core，否则无视。求所有符合要求的区域中一共多少个 1 即体积。

&emsp;&emsp;基础 BFS 题，注意搜索的是上面图示的邻近 6 个结点，做好边界判断。

## Code

``` cpp 
#include <bits/stdc++.h>
using namespace std;

int M, N, L, T, G[65][1300][130];
int dh[] = {1, 0, 0, 0, 0, -1}, dx[] = {0, -1, 0, 1, 0, 0}, dy[] = {0, 0, 1, 0, -1, 0};

struct Node {
    int x, y, h;
};

int bfs(int h, int x, int y) {
    queue<Node> que;
    que.push(Node{x, y, h});
    int cnt = 0;
    while (!que.empty()) {
        Node node = que.front();
        que.pop();
        cnt++;
        for (int i = 0; i < 6; i++) {
            int nh = node.h + dh[i];
            int nx = node.x + dx[i];
            int ny = node.y + dy[i];
            if (nh < 0 || nh >= L || nx < 0 || nx >= M || ny < 0 || ny >= N || G[nh][nx][ny] == 0) continue;
            G[nh][nx][ny] = 0;
            que.push(Node{nx, ny, nh});
        }
    }
    return cnt;
}

int main() {
    scanf("%d %d %d %d", &M, &N, &L, &T);
    for (int i = 0; i < L; i++) {
        for (int j = 0; j < M; j++) {
            for (int k = 0; k < N; k++) {
                scanf("%d", &G[i][j][k]);
            }
        }
    }
    int ans = 0;
    for (int i = 0; i < L; i++) {
        for (int j = 0; j < M; j++) {
            for (int k = 0; k < N; k++) {
                if (G[i][j][k] == 1) {
                    G[i][j][k] = 0;
                    int tmp = bfs(i, j, k);
                    if (tmp >= T) ans += tmp;
                }
            }
        }
    }
    cout << ans;
}
```

## Tsukkomi

&emsp;&emsp;30 分白送，嘻嘻。