---
title: PAT-A 1151 LCA in a Binary Tree (30)
urlname: pat-a-1151
date: 2020-07-14 23:38:13
toc: true
categories:
    - Note
    - Problem
tags:
    - PAT
---

{% raw %}<article class="message is-danger"><div class="message-body">{% endraw %}
<span class="icon"><i class="fa fa-star mr-2"></i></span>&nbsp;&nbsp;通过先序和中序寻找两个结点的最近共同祖先。
{% raw %}</div></article>{% endraw %}

The lowest common ancestor (LCA) of two nodes U and V in a tree is the deepest node that has both U and V as descendants.

Given any two nodes in a binary tree, you are supposed to find their LCA.

<!--more-->

**Problem:**&nbsp;[PAT-A 1151 LCA in a Binary Tree](https://pintia.cn/problem-sets/994805342720868352/problems/1038430130011897856 "PAT-A 1151 LCA in a Binary Tree")

## Input Specification

Each input file contains one test case. For each case, the first line gives two positive integers: M (≤ 1,000), the number of pairs of nodes to be tested; and N (≤ 10,000), the number of keys in the binary tree, respectively. In each of the following two lines, N distinct integers are given as the inorder and preorder traversal sequences of the binary tree, respectively. It is guaranteed that the binary tree can be uniquely determined by the input sequences. Then M lines follow, each contains a pair of integer keys U and V. All the keys are in the range of **int**.

## Output Specification

For each given pair of U and V, print in a line `LCA of U and V is A.` if the LCA is found and `A` is the key. But if `A` is one of U and V, print `X is an ancestor of Y.` where `X` is `A` and `Y` is the other node. If U or V is not found in the binary tree, print in a line `ERROR: U is not found.` or `ERROR: V is not found.` or `ERROR: U and V are not found.`.

## Sample Input

```
6 8
7 2 3 4 6 5 1 8
5 3 7 2 6 4 8 1
2 6
8 1
7 9
12 -3
0 8
99 99
```

## Sample Output

```
LCA of 2 and 6 is 3.
8 is an ancestor of 1.
ERROR: 9 is not found.
ERROR: 12 and -3 are not found.
ERROR: 0 is not found.
ERROR: 99 and 99 are not found.
```

## Analysis

&emsp;&emsp;题目大意：提供二叉树的中序和先序遍历，然后 M 对结点，寻找每对结点 (U 和 V) 的最近共同祖先，按规定格式输出结果。

&emsp;&emsp;在先序中设置光标，选择结点作为根结点。然后在通过中序判断当前根结点与 U 和 V 的位置关系。注意需要保存各结点在中序中的下标，通过下标进行上述判断，详情见代码。

## Code

``` cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> in, pre;
map<int, int> mp;
int M, N, u, v, inU, inV;

// inL 为中序的左边界, preCur 为先序中的游标，即当前选中的根结点
void LCA(int inL, int preCur) {
    // 获取当前根结点在中序中的下标
    int inRoot = mp[pre[preCur]];

    if ((inU < inRoot && inV > inRoot) || (inU > inRoot && inV < inRoot)) {
        cout << "LCA of " << u << " and " << v << " is " << in[inRoot] << "." << endl;
    } else if (inU < inRoot && inV < inRoot) {  // U, V 在当前根结点的左子树
        LCA(inL, preCur + 1);
    } else if (inU > inRoot && inV > inRoot) {  // U, V 在当前根结点的右子树
        LCA(inRoot + 1, preCur + (inRoot - inL) + 1);
    } else if (inU == inRoot) {  // U 为根结点
        cout << u << " is an ancestor of " << v << "." << endl;
    } else if (inV == inRoot) {  // V 为根结点
        cout << v << " is an ancestor of " << u << "." << endl;
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin >> M >> N;
    in.resize(N + 1), pre.resize(N + 1);
    for (int i = 1; i <= N; i++) {
        cin >> in[i];
        mp[in[i]] = i;  // 保存结点的中序下标
    }
    for (int i = 1; i <= N; i++) {
        cin >> pre[i];
    }
    for (int i = 0; i < M; i++) {
        cin >> u >> v;
        if (!mp[u] && !mp[v]) {
            cout << "ERROR: " << u << " and " << v << " are not found." << endl;
        } else if (!mp[u] || !mp[v]) {
            cout << "ERROR: " << (!mp[u] ? u : v) << " is not found." << endl;
        } else {
            inU = mp[u], inV = mp[v];  // 获取 U, V 在中序中的下标
            LCA(1, 1);
        }
    }
}
```

## Tsukkomi

&emsp;&emsp;没啥吐槽的，碎了……