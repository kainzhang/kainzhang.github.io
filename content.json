{"pages":[],"posts":[{"title":"N皇后（N-Queens）","text":"LeetCode 51 N-Queens LeetCode 52 N-Queens II Lanqiao BASIC-27 2N-Queens Lanqiao ADV-203 8-Queens N-QueensDescription&emsp;&emsp;n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 &emsp;&emsp; &emsp;&emsp;上图为 8 皇后问题的一种解法。 &emsp;&emsp;给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。 &emsp;&emsp;每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。 &emsp;&emsp;原题：LeetCode 51 N-Queens Sample123456789101112131415输入: 4输出: [ [&quot;.Q..&quot;, // 解法 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, // 解法 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;]]解释: 4 皇后问题存在两个不同的解法。 Thought&emsp;&emsp;题目要求将n个皇后放置在n * n大小的棋盘上，皇后之间不能打架，也就是每行、每列、每条对角线上不能同时有两位皇后。 &emsp;&emsp;思路就是深搜回溯，从第1行开始每次逐列放置皇后，每次放置时对已经放置完成的行进行判断，能放则放，不能放则弃。也就是检查当前位置皇后的上、左上、右上方是否存在皇后。完成n个皇后放置任务后将当前棋盘添加至结果集。 Code&emsp;&emsp;觉得这题难度其实不大，就是个人在效率上有点难受（再见残酷的世界！），第1版写完交上去虽然一次AC了，但时间和空间居然都被95%的人碾压？？？（拐回来看代码发现参数全是形参，改了引用参数后时间击败60%空间击败100%）然后参考老哥们的题解改了改，还凑合吧，粘两个版本留念。 Version 1&emsp;&emsp;直接把整个棋盘开出来了，然后逐行放置皇后。检查已放置的行就开了3个for循环，分别对正上、左上、右上的格子进行遍历判断。 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution {public: bool isValid(vector&lt;string&gt;&amp; bd, int row, int col) { //正上 for(int i = 0; i &lt; row; i++) { if(bd[i][col] == 'Q') return false; } //左上 for(int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--) { if(bd[i][j] == 'Q') return false; } //右上 for(int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; bd.size(); i--, j++) { if(bd[i][j] == 'Q') return false; } return true; } void dfs(vector&lt;string&gt;&amp; bd, int row, int n) { if(row == n) { res.push_back(bd); return; } for(int i = 0; i &lt; n; i++) { if(isValid(bd, row, i)) { bd[row][i] = 'Q'; dfs(bd, row + 1, n); bd[row][i] = '.'; } } } vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) { vector&lt;string&gt; bd(n, string(n, '.')); dfs(bd, 0, n); return res; }private: vector&lt;vector&lt;string&gt;&gt; res;}; Version 2&emsp;&emsp;棋盘是按行开辟的，凑够一整盘后带走放入结果集（空间上没有影响，就是单纯尝试下。。。） &emsp;&emsp;这个判断比较有意思，是在题解区学的。先开个数组用来存放棋盘每一行放置皇后的列值，在判断时，如果当前列与数组中的列重复，即正上方有皇后。对角线点坐标的x, y与当前点相减的绝对值是相同的，由此判断对角线上是否存在皇后。 123456789101112131415161718192021222324252627282930313233343536373839class Solution {public: bool isValid(int row, int col, vector&lt;int&gt; &amp;pos) { for (int i = 0; i &lt; row; i++) { if (col == pos[i] || abs(row - i) == abs(pos[i] - col)) return false; } return true; } void dfs(int row, int n, vector&lt;int&gt; &amp;pos, string &amp;line) { if (row == n) { res.push_back(tmp); return; } for (int i = 0; i &lt; n; i++) { if (isValid(row, i, pos)) { line[i] = 'Q'; tmp.push_back(line); line[i] = '.'; pos[row] = i; dfs(row + 1, n, pos, line); pos[row] = -1; tmp.pop_back(); } } } vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) { string line(n, '.'); vector&lt;int&gt; pos(n, -1); dfs(0, n, pos, line); return res; }private: vector&lt;vector&lt;string&gt;&gt; res; vector&lt;string&gt; tmp;}; &emsp; N-Queen IIDescription&emsp;&emsp;n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 &emsp;&emsp; &emsp;&emsp;上图为 8 皇后问题的一种解法。 &emsp;&emsp;给定一个整数 n，返回 n 皇后不同的解决方案的数量。 &emsp;&emsp;原题：LeetCode 52 N-Queens II Sample12345678910111213141516输入: 4输出: 2解释: 4 皇后问题存在如下两个不同的解法。[ [&quot;.Q..&quot;, // 解法 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, // 解法 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;]] Thought&emsp;&emsp;怎么说呢，我严重怀疑LeetCode的临时工把题号标错了，这个虽然是II，但明显是原版的简化。看见题就没多想，直接复制粘贴上一题代码，删掉所有棋盘数据，只保留存放每行皇后位置的数组，跑都没跑就提交了（也就这时候敢浪）。在题解区看到用位运算好像效率蛮高的，改（有）天（缘）再看吧。 Code12345678910111213141516171819202122232425262728293031class Solution {public: bool isValid(int row, int col, vector&lt;int&gt; &amp;pos) { for (int i = 0; i &lt; row; i++) { if (col == pos[i] || abs(row - i) == abs(pos[i] - col)) return false; } return true; } void dfs(int row, int n, vector&lt;int&gt; &amp;pos, int &amp;res) { if (row == n) { res++; return; } for (int i = 0; i &lt; n; i++) { if (isValid(row, i, pos)) { pos[row] = i; dfs(row + 1, n, pos, res); pos[row] = -1; } } } int totalNQueens(int n) { vector&lt;int&gt; pos(n, -1); int res = 0; dfs(0, n, pos, res); return res; }}; &emsp; 2N-QueensDescription&emsp;&emsp;给定一个n*n的棋盘，棋盘中有一些位置不能放皇后。现在要向棋盘中放入n个黑皇后和n个白皇后，使任意的两个黑皇后都不在同一行、同一列或同一条对角线上，任意的两个白皇后都不在同一行、同一列或同一条对角线上。问总共有多少种放法？n小于等于8。 Input: &emsp;&emsp;输入的第一行为一个整数n，表示棋盘的大小。 &emsp;&emsp;接下来n行，每行n个0或1的整数，如果一个整数为1，表示对应的位置可以放皇后，如果一个整数为0，表示对应的位置不可以放皇后。 Output: &emsp;&emsp;输出一个整数，表示总共有多少种放法。 Sample12345678910111213141516171819输入: // Sample 141 1 1 11 1 1 11 1 1 11 1 1 1输出:2输入: // Sample 241 0 1 11 1 1 11 1 1 11 1 1 1输出:0 Thought&emsp;&emsp;和N皇后的思路一样，区别是放置两种颜色的皇后，也就是黑白皇后各来一次深搜。根据题意，棋盘上1代表可以放置，0代表不可放置。用2表示白皇后，用3表示黑皇后。放置白皇后时遇到0跳过，放置黑皇后时遇到0和2跳过，两种颜色全部放完时（q == 4)结束并计数。 Code123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;int n, bd[10][10], res = 0;bool isValid(int row, int col, int q) { // q 为皇后类型 for (int r = row - 1, t = 1; r &gt;= 0; r--, t++ ) { if (bd[r][col] == q || (col - t &gt;= 0 &amp;&amp; bd[r][col - t] == q) || (col + t &lt; n &amp;&amp; bd[r][col + t] == q)) { return false; } } return true;}void dfs(int row, int q) { if (q == 4) { // 黑白皇后均已放完 res++; return; } else if (row == n) { dfs(0, q + 1); // 放置另一种颜色的皇后 return; } for (int col = 0; col &lt; n; col++) { if (bd[row][col] == 0 || bd[row][col] == 2) continue; if (isValid(row, col, q)) { bd[row][col] = q; dfs(row + 1, q); bd[row][col] = 1; } }}int main() { scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) scanf(\"%d\", &amp;bd[i][j]); dfs(0, 2); cout &lt;&lt; res &lt;&lt; endl;} &emsp; 8-QueensDescription&emsp;&emsp;规则同8皇后问题，但是棋盘上每格都有一个数字，要求八皇后所在格子数字之和最大。 Input: &emsp;&emsp;一个8*8的棋盘。 Ouput: &emsp;&emsp;所能得到的最大数字和 Sample1234567891011121314输入:1 2 3 4 5 6 7 89 10 11 12 13 14 15 1617 18 19 20 21 22 23 2425 26 27 28 29 30 31 3233 34 35 36 37 38 39 4041 42 43 44 45 46 47 4848 50 51 52 53 54 55 5657 58 59 60 61 62 63 64输出:260数据规模和约定: 棋盘上的数字范围 0~99 Thought&emsp;&emsp;依然是深搜回溯，各个位置的数字已经给了，并且题目说明了数字范围为0~99，所以我们将访问的数字累加，并将值改为-1表示已经访问过，确保不被重复访问。每次满足终止条件时，比较当前放置方法的数字之和，取最大值即可。 Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;int n = 8, bd[10][10], res = 0;bool isValid(int row, int col) { for (int r = row - 1, t = 1; r &gt;= 0; r--, t++ ) { if (bd[r][col] == -1 || (col - t &gt;= 0 &amp;&amp; bd[r][col - t] == -1) || (col + t &lt; n &amp;&amp; bd[r][col + t] == -1)) { return false; } } return true;}void dfs(int row, int sum) { if (row == n) { res = max(res, sum); return; } for (int col = 0; col &lt; n; col++) { if (isValid(row, col)) { int tmp = bd[row][col]; bd[row][col] = -1; dfs(row + 1, sum + tmp); bd[row][col] = tmp; } }}int main() { for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) scanf(\"%d\", &amp;bd[i][j]); dfs(0, 0); cout &lt;&lt; res &lt;&lt; endl;} &emsp; Summary&emsp;&emsp;总得来说就是简单的暴力深搜回溯，逻辑上没什么细节好抠的。虽然LeetCode标记的难度是Hard，但实际其实还好？不过第一次信心满满地交上去，结果时间和空间都只击败5%真的难受（弱鸡枯了），确实自己经常粗心忘打取地址符，导致内存使用翻倍，尤其是变量名很长的时候都是习惯性复制粘贴，就忘了。 &emsp;&emsp;蓝桥的比LeetCode难度稍大，比较有意思的是蓝桥的2N皇后被放在“基础练习”的试题集，而相较而言更简单的8皇后被放在“算法提高”？？？可能跟LeetCode是同一个临时工吧哈哈哈哈。 unsplash-logoMichał Parzuchowski","link":"/blog/problem/200408-n-queens/"},{"title":"Coding托管Hexo及CloudFlare域名解析","text":"&emsp;&emsp;心血来潮买了个域名，迫不及待地把它绑定到博客。为了提升加载速度分别尝试了Coding和Gitee托管以及CloudFlare的CDN加（减）速。最终决定使用Github和Coding的双托管，使用CloudFlare把域名解析到Coding。 &emsp;&emsp;这个.me的黑山国家域名我蛮喜欢的，虽然觉得.cc好像更可爱，但个人博客确实还是.me更适合。于是我的小博客迎来全新的域名，Github Page也沦为备胎，嘻嘻。 使用Coding托管Hexo创建项目&emsp;&emsp;首先就是注册账号，创建仓库，流程与Github一样，项目模板选择代码托管项目。项目名称随你，其他的默认就好。Coding没要求必须公开源代码，README也可不添加。 &emsp;&emsp; 本地Hexo设置&emsp;&emsp;进入建好的仓库中，复制页面右边提供的仓库SSH地址。 &emsp;&emsp; &emsp;&emsp;将SSH粘贴至Hexo的_config.yml对应位置，换行加上就行，注意格式。没错，加上Gitee三托管也可以的，喜欢就只管加上。下次hexo d的时候就会一起发布。 &emsp;&emsp; 添加SSH公钥&emsp;&emsp;为了方便发布，把之前搞Github Page生成的SSH密钥添加到Coding，SSH密钥一般藏在下面这个位置。 C:\\Users\\用户名.ssh\\id_rsa.pub &emsp;&emsp;在Coding页面右上角的弹框里找到个人设置，然后添加SSH公钥，复制粘贴确认即可。之后使用hexo d发布时会需要确认，yes就好。 静态页面部署&emsp;&emsp;Hexo生成的静态网页被发布到Coding仓库后，进入项目页面，页面左下角找到项目设置 -&gt; 项目于成员 -&gt; 功能开关，然后打开持续集成和持续部署，之后才能部署静态页面。 &emsp;&emsp; &emsp;&emsp;开启上述两项功能后，回到项目主页，左边目录多了持续集成和持续部署两个选项，找到静态网站选项，立即部署即可。Coding会自动生成一个地址（我看网上别人的都是coding.me的域名，可能现在改了吗？还是我操作不对？无所谓啦），然后就发布成功啦!点开那个丑陋的网址看看吧！ &emsp;&emsp; 自定义域名&emsp;&emsp;Coding Pages生成的域名实在是不能接受，赶紧买域名！ 购买域名&emsp;&emsp;年幼无知的我没做足功课就把第一次献给了 GoDaddy，在这里建议萌新在购买域名前，一定要先在 domcomp 查询一下，这里可以查到你喜欢的域名的最便宜价格及提供该价格的注册商，也可以顺便选一下顶级域名。除了GoDaddy外，dynadot 也是支持支付宝的。 &emsp;&emsp;由于我是之后才知道domcomp的，已经在GoDaddy，买过了。流程就是选域名，加购物车，然后顺便注册账号，按提示来就vans了。 绑定域名&emsp;&emsp;购买成功后找到购买的域名，点击DNS管理，配置CNAME和A，CNAME值为Coding Pages的地址，A值为对应的IP，不知道IP的话在 站长工具 ping以下即可，一般会有四个新加坡腾讯云的IP，分别添加即可。如果想解析到Github Pages，同理，Github Pages也是四个IP，分别添加即可。 &emsp;&emsp;Github Pages一般是下面这四个,Coding Pages的我不确定，具体以ping的结果为准。 185.199.108.153185.199.109.153185.199.110.153185.199.111.153 &emsp;&emsp;配置完成后回到Coding，在静态网站中找到设置，在绑定新域名处添加域名，如果你没有配置DNS是会提示申请证书失败的。另外由于网站是由Coding或Github托管的，所以不需要备案，正确配置CNAME即可。待证书状态显示正常，域名就绑定成功了，用新域名访问博客吧！ CloudFlare域名解析&emsp;&emsp;上一步在GoDaddy的DNS配置可以直接省略，在CloudFlare进行，账号注册成功后，点击添加站点（会自动弹出），然后输入刚买的域名，之后CloudFlare会提供两个NS地址，要求在域名注册商那里修改NS地址。 &emsp;&emsp; &emsp;&emsp;回到GoDaddy，进入域名管理，修改域名服务器，吧CloudFlare提供的两个NS地址复制进去，然后确认，之后会显示：我们无法显示您的 DNS 信息，因为您的域名服务器不是由我们管理的。 OK，GoDaddy可以关了。 &emsp;&emsp; &emsp;&emsp;返回CloudFlare后点击已修改（忘了具体名称了，看页面提示就行），然后会提示在排队。修改域名服务器后需要稍等一会CloudFlare才有反应。 &emsp;&emsp;域名在CloudFlare这边添加成功后，点击域名进入域名管理界面，找到DNS，按照下面的格式配置。其中小云朵标志代表开启CDN加速，如果你网站的主要访客来自境外，那么建议开启，橙色代表开启。国内的话就关闭吧，速度比Github还慢。关掉后只使用域名解析。 &emsp;&emsp; &emsp;&emsp;刚绑定完的域名不出意外的话，访问博客时浏览器会提示不安全，CloudFlare可以轻松解决。域名管理页面找到SSL/TLS，确认SSL/TLS加密模式为完全，一般默认就是完全。 &emsp;&emsp; &emsp;&emsp;之后在边缘证书栏目找到始终使用HTTPS，确认该项为开启状态。之后就慢慢等吧，CloudFlare会在24小时内为域名发放证书。 &emsp;&emsp; 总结&emsp;&emsp;这一波折腾完，我的Github博客基本就是摆设了，CloudFlare好像不能国内外分流，无力实现境外访客解析到Github，境内访客解析到Coding，或者你知道怎么搞的话可以告诉我，不胜感激！ &emsp;&emsp;我还尝试了Gitee Pages，速度还蛮快的，Ping一下全国都是深绿的，有条件的话用Gitee托管效果还是不错的。搭建流程跟Github Pages一样，项目名称使用用户名能开启 XXX.gitee.io的地址，否则地址末尾会包含项目名。但是Gitee很抠，升级pro版才能自定义域名和自动部署，普通版每次发布后要手动更新，pro每年99元。新用户有1个月的免费体验，我试了下，但是配置证书的时候出了问题，Gitee要求粘贴域名证书和密钥，因为我是在CloudFlare解析的，就没成功（可能是我太笨），如果你搞定了也一定要告诉我，再次感激！ &emsp;&emsp;Coding Pages用的新加坡的腾讯云，速度比Gitee用的国内的阿里云肯定要慢的，但是比Github强多了，还行吧，ping一下看看我觉得还行吧，我还是挺容易满足的。 &emsp;&emsp; unsplash-logoLouie Martinez","link":"/blog/diary/200427-diary/"},{"title":"工厂模式（Factory Pattern）","text":"&emsp;&emsp;Java常用设计模式 —— 工厂模式 简单工厂模式简单工厂模式组成： 工厂类：简单工厂模式的核心，负责创建所需的产品实例。 抽象产品类：产品类的父类，定义产品类共有的属性和方法。 产品类： 继承抽象产品类，即具体的产品。 &emsp;&emsp;首先定义抽象咖啡类，规定所有咖啡共有的接口。 123456789101112131415public abstract class Coffee { protected String name; // 制作咖啡 public void prepare() { System.out.println(name + \"制作完成！\"); } // 打包咖啡 public void pack() { System.out.println(name + \"打包完成!\"); }} &emsp;&emsp;定义具体类型的咖啡。 1234567891011121314151617public class Americano extends Coffee{ public Americano() { this.name = \"美式\"; }}public class Latte extends Coffee{ public Latte() { this.name = \"拿铁\"; }}public class Mocha extends Coffee{ public Mocha() { this.name = \"摩卡\"; }} &emsp;&emsp;创建咖啡工厂类，负责具体产品的实例化 1234567891011121314public class CoffeeFactory { public Coffee createCoffee(String coffeeType) { Coffee coffee = null; if (coffeeType.equals(\"美式\")) { coffee = new Americano(); } else if (coffeeType.equals(\"拿铁\")) { coffee = new Latte(); } else if (coffeeType.equals(\"摩卡\")) { coffee = new Mocha(); } return coffee; }} &emsp;&emsp;咖啡馆类调用咖啡工厂类。 123456789101112131415161718192021222324public class Cafe { private static String getCoffeeType() { try { BufferedReader strin = new BufferedReader(new InputStreamReader(System.in)); System.out.println(\"请输入咖啡类别：\"); String str = strin.readLine(); return str; } catch (IOException e) { e.printStackTrace(); return \"\"; } } public static void main(String[] args) { CoffeeFactory cf = new CoffeeFactory(); String coffeeType = getCoffeeType(); Coffee coffee = cf.createCoffee(coffeeType); if (coffee != null) { coffee.prepare(); coffee.pack(); } else { System.out.println(\"请求失败！\"); } }} unsplash-logoTyler Nix","link":"/blog/designpattern/200425-factory-pattern/"},{"title":"First diary, Hello world!","text":"&emsp;&emsp;很早就想搞个博客记录学习和生活，留给未来回首往日。Emmm…之所以拖到今天才开始着手，一方面是因为疫情一直宅家想充实，一方面是面临考研，发现自己两年半来居然一点学习笔记也没留下。想想CXK练习时长两年半都出道了，自己考研前的寒假还爆肝了四五周游戏（u1s1，DQB2是真的香），爆肝之后的贤者模式告诉我，不能继续在游戏中堕落下去（该换个方式堕落了)，这也是为什么我会在这里用小学作文的水平码字。。。 &emsp;&emsp;产生这个想法是在大一时期，当时在老师的倡导下在学校OJ刷题，经常刷到凌晨（虽然水平没提升的多少，但头顶确实越来越冷了），题目怼不出来就复制题号在网上搜，也由此见识了很多大佬的CSDN、博客园博客，惊叹于大佬的解题能力和刷题量，也包括很多大佬的学习笔记、随笔 blahblah，当时就想着什么时候咱也得整一个！ &emsp;&emsp;然鹅只恨自己太懒，大一下学期题几乎不刷题了，很少再去搜题解（了解到学院不参加ACM，觉得刷题失去意义）。大二虽然学院突然开始参加比赛了，但糟糕的时间安排和被各种破事占用时间，刷题都没得刷，更别提写博客了，于是博客计划无限期搁置。。。 &emsp;&emsp;2020的寒假意外得长，寒假前我还计划像以往假期一样每天早起去图书馆，然鹅疫情就这么来了，一切安排都被打乱。19年底我甚至计划20暑假去日本玩些日子，组了小伙伴也做了很多功课，但是照现在的情况来看，扶桑之旅多半是gg了。 &emsp;&emsp;大概4月底会开学吧，说实话宅家虽然没劲儿学，但我是一点不希望开学，原因是多方面的，仁者见仁智者见智就不细写了。不过考研和就业的临近确实让我提了点劲儿，我又开始刷题了，尽管依然菜得抠脚，但终于算是能静下心学习。目前的目标就是PAT甲级吧，原本3月考，因为疫情被延到了6月底，算是多给我几个月时间蹦跶哈哈哈哈。同时还在准备托福和N2，然鹅到现在也没见报名消息，难过。 &emsp;&emsp;为了整这个博客我牺牲了整整一个下午，从纠结Jekyll还是Hexo，到选主题拿不定主意，然后终于选定主题，字号配色又整不好了（整完提交上去排版崩了，又reset）。反正就是完美主义，一次次地推翻自己，不断的装了改、改了删、删了再装，没完没了，我还自己用Procreate手写了个Logo（丢人，估计过几天就得换），大概这也算是一种自虐？（笑） &emsp;&emsp;总而言之，希望自己能坚持下去，定期总结学习、总结生活（虽然语文丢人）。坚守自己21年暑假考日本的目标，趁着年轻再搏一搏，虽然软件行业好像不很重视学历，但考硕确实是实现名校情结的最后机会了！给我冲！頑張る","link":"/blog/diary/200401-diary/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"Lanqiao","slug":"Lanqiao","link":"/tags/Lanqiao/"},{"name":"BackTracking","slug":"BackTracking","link":"/tags/BackTracking/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"Java","slug":"Java","link":"/tags/Java/"}],"categories":[{"name":"Note","slug":"Note","link":"/categories/Note/"},{"name":"Diary","slug":"Diary","link":"/categories/Diary/"},{"name":"Problem","slug":"Note/Problem","link":"/categories/Note/Problem/"},{"name":"Design Pattern","slug":"Note/Design-Pattern","link":"/categories/Note/Design-Pattern/"}]}