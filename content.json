{"pages":[],"posts":[{"title":"Github+PicGo+jsDelivr搭建博客图床","text":"&emsp;&emsp;刷CSDN瞟到jsDelivr这个免费CDN，在官网了解一下发现可以加速Github项目。想到GithubPages加载缓慢，就赶紧深入学习。然后我惊奇发现，原来我用的Icarus主题已经用了jsDelivr的CDN，大一时写界面的Bootstrap也用了！它就在身边我居然今天（昨晚）才知道？ &emsp;&emsp;图床是早就有了解的，但是一直没考虑尝试，一方面是懒，另一方面是不想把图片传到别人的空间。现在能用Github做图床，岂不美哉？ 使用Github配置PicGo&emsp;&emsp;流程很简单，在 这里 下载客户端，然后按照 官方文档 一步步来就vans了，写的很详细，我就不瞎扯了。 使用jsDelivr CDN&emsp;&emsp;依然很简单，你甚至 jsDelivr 官网都不用进，直接用走jsDelivr CDN的URL获取图片就好了，在PicGo的Github设置页面设置自定义域名，格式如下。之后上传的图片直接复制URL就是走CDN的了。 https://cdn.jsdelivr.net/gh/&lt;用户名&gt;/&lt;仓库名&gt; 使用中遇到的坑&emsp;&emsp;PicGo间歇性失灵，出现上传失败的话，就关闭重启试试。 总结&emsp;&emsp;用着很爽，不影响我水博文，图片加载速度显著提高。发文章时把图片拖拽到PicGo的上传区，然后在相册点击复制URL即可。就是用Github做图床导致小绿点看着很虚假（嘻嘻）。 unsplash-logoAnton Darius","link":"/2020/05/01/image-hosting/"},{"title":"使用Travis CI部署Hexo博客","text":"&emsp;&emsp;使用Travis CI部署Hexo博客是Hexo官方文档推荐的部署方法，但是博客源文件会被公开。起初就是因为这一点没有使用Travis CI部署，但是刚成功部署完Hexo发了第一篇博文后我就在想，博客源文件都在本地，如果我换电脑了或者源文件不在身边或者电脑坏了怎么办？岂不是很麻烦？我这么怕麻烦个人… &emsp;&emsp;当时就搜了这个问题，果然大佬们早就提供了解决方案。一般都是把源文件也放在github，或者推送到分支。我想既然都放到分支上了，不如直接按官方推荐的，用Travis CI部署，这样甚至可以随时随地修改博文，即便本地没有环境，也可以把md交到仓库即时发布。 关于Travis CI&emsp;&emsp;Travis CI提供持续集成服务，目前仅支持Github项目。它提供环境帮用户构建、测试、部署项目，在你提交代码后，它会clone你的项目，配置环境并安装依赖，然后返回运行结果。具体内容请查阅 官方文档。 &emsp;&emsp;放到Github Pages部署的Hexo来说，就是当你的Hexo项目有改变时，它会帮你生成静态文件，并部署到你指定的项目分支。 部署Hexo&emsp;&emsp;Hexo官方文档 提供了详细的步骤，我就记录一些遇到的坑吧。 分支问题&emsp;&emsp;按照Hexo官方文档的步骤，Hexo项目被推送到项目Master分支，然后由Travis CI将静态文件发布至gh-pages分支，在Github Pages设定中选择gh-pages分支进行部署。我记得不久前Github Pages还是可以自行选择分支的，但现在仅支持部署Master分支了，如图。 &emsp;&emsp;也就是说Master分支要放静态文件，另开一个分支放源文件。第一次部署Hexo的朋友需要注意这个问题，对于已经把静态文件推送到Master分支的朋友来说，没有任何影响，源文件直接推送新的分支就vans了。 12345git initgit add .git commit -m \"init blog\"git remote add origin https://github.com/&lt;用户名&gt;/&lt;用户名&gt;.github.io.gitgit push origin master:hexo &emsp;&emsp;注意配置.travis.yml，这里把源文件推送到hexo分支。 .travis.yml12345678910111213141516171819sudo: falselanguage: node_jsnode_js: - 10cache: npmbranches: only: - hexo # 对Hexo分支进行构建script: - hexo generatedeploy: provider: pages skip-cleanup: true github-token: $GH_TOKEN target-branch: master # 设置部署的目标分支 keep-history: true on: branch: hexo local-dir: public 仓库冲突问题&emsp;&emsp;按照官方文档操作完毕，.travis.yml也配置完成，使用脚本一套操作把文件推送到Github，默默等待Travis CI部署我的博客。刷新浏览器检验是否成功，居然白板？？赶紧查Travis CI的记录，提示no layout，仓库内的主题文件没有被推送导致静态文件压根没生成！ &emsp;&emsp; &emsp;&emsp;拐回来看被我无视的bash记录，项目内居然有关联别的仓库？是clone icarus主题时带来的。根据提示输入 git rm –cached themes/icarus 是不行的，icarus目录内存在.git 目录需要删除。 &emsp;&emsp; &emsp;&emsp;进入icarus目录直接删除文件夹。问题解决。 gitignore问题&emsp;&emsp;解决仓库冲突问题后，我又推送了，这回推送过程没问题，Travis CI构建静态文件倒是出了问题。刷新浏览器依然时白板，Travsi CI记录是这样的。 &emsp;&emsp; &emsp;&emsp;icarus主题目录里缺了配置文件_config.yml,当icarus发现目录内没有配置文件时会自动创一个，这锅必须是.gitignore的，点开文件发现里面赫然记录着_config.yml,赶紧删掉！ 总结&emsp;&emsp;Travis CI能够提供环境，帮助构建、测试及部署Hexo项目，使用Travis CI部署博客满足了随时随地修改内容的强迫症需求，解决了出差、旅游时不方便水博文的问题，也解决了随着博客内容不断增多造成的生成及推送静态文件时的等待问题（虽然并不多）。优雅地推送源文件就vans了，或者在仓库添加/修改md文件。暂时还没有尝试在其他主机配置Hexo本地文件。以上。 unsplash-logoMichael Liao","link":"/2020/05/02/travis-ci-deploy-hexo/"},{"title":"MacOS 安装及配置 MongoDB","text":"官网下载压缩包MongoDB官网 选择相应版本并下载压缩包，解压后将文件夹放至喜欢的地方，用喜欢的名字重命名，我放在了 Home 目录下。 配置环境变量打开终端修改以下文件。 1vim ~/.zshrc 添加以下内容，地址为 MongoDB 的二进制文件夹地址。 1export PATH=/Users/kainzhang/mongodb/bin:${PATH} 保存退出，使环境变量生效 1source ~/.zshrc 启动 MongoDB成果配置环境变量后，在喜欢的位置为 MongoDB 创建 data 文件夹，我在 Home 目录下创建了 mongodb-data。终端使用如下代码运行启动 MongoDB server，同时指定 dbpath。服务器默认在 27017 端口，不清楚为啥 4.4.5 的 log 显示成这样，4.0.24 的挺好的。 1mongod --dbpath /Users/kainzhang/mongodb-data cmd + t 打开新的终端 tab，启动 MongoDB Shell 连接 Server。 1mongo 一些基础操作。 关闭 MongoDB推荐使用如下命令关闭 Server，否则会导致端口占用，影响下次使用。在 Shell 这边输入如下指令。 安装 MongoDB CompassMongoDB 的图形化界面，官网下载安装或者运行压缩包中的install_compass，配置过环境变量后可以直接终端执行命令。 1install_compass","link":"/2021/05/09/install-mongodb-on-macos/"},{"title":"设计模式 - 工厂模式（Factory Pattern）","text":"&emsp;&emsp;Java设计模式 - 工厂模式 简单工厂模式简单工厂模式组成： 工厂类：简单工厂模式的核心，负责创建所需的产品实例。 抽象产品类：产品类的父类，定义产品类共有的属性和方法。 产品类： 继承抽象产品类，即具体的产品。 &emsp;&emsp;首先定义抽象咖啡类，规定所有咖啡共有的接口。 123456789101112131415public abstract class Coffee { protected String name; // 制作咖啡 public void prepare() { System.out.println(name + \"制作完成！\"); } // 打包咖啡 public void pack() { System.out.println(name + \"打包完成!\"); }} &emsp;&emsp;定义具体类型的咖啡。 1234567891011121314151617public class Americano extends Coffee{ public Americano() { this.name = \"美式\"; }}public class Latte extends Coffee{ public Latte() { this.name = \"拿铁\"; }}public class Mocha extends Coffee{ public Mocha() { this.name = \"摩卡\"; }} &emsp;&emsp;创建咖啡工厂类，负责具体产品的实例化 1234567891011121314public class CoffeeFactory { public Coffee createCoffee(String coffeeType) { Coffee coffee = null; if (coffeeType.equals(\"美式\")) { coffee = new Americano(); } else if (coffeeType.equals(\"拿铁\")) { coffee = new Latte(); } else if (coffeeType.equals(\"摩卡\")) { coffee = new Mocha(); } return coffee; }} &emsp;&emsp;咖啡馆类调用咖啡工厂类。 123456789101112131415161718192021222324public class Cafe { private static String getCoffeeType() { try { BufferedReader strin = new BufferedReader(new InputStreamReader(System.in)); System.out.println(\"请输入咖啡类别：\"); String str = strin.readLine(); return str; } catch (IOException e) { e.printStackTrace(); return \"\"; } } public static void main(String[] args) { CoffeeFactory cf = new CoffeeFactory(); String coffeeType = getCoffeeType(); Coffee coffee = cf.createCoffee(coffeeType); if (coffee != null) { coffee.prepare(); coffee.pack(); } else { System.out.println(\"请求失败！\"); } }} unsplash-logoTyler Nix","link":"/2020/04/25/factory-pattern/"},{"title":"First diary, Hello world!","text":"&emsp;&emsp;很早就想搞个博客记录学习和生活，留给未来回首往日。Emmm…之所以拖到今天才开始着手，一方面是因为疫情一直宅家想充实，一方面是面临考研，发现自己两年半来居然一点学习笔记也没留下。想想CXK练习时长两年半都出道了，自己考研前的寒假还爆肝了四五周游戏（u1s1，DQB2是真的香），爆肝之后的贤者模式告诉我，不能继续在游戏中堕落下去（该换个方式堕落了)，这也是为什么我会在这里用小学作文的水平码字。。。 &emsp;&emsp;产生这个想法是在大一时期，当时在老师的倡导下在学校OJ刷题，经常刷到凌晨（虽然水平没提升的多少，但头顶确实越来越冷了），题目怼不出来就复制题号在网上搜，也由此见识了很多大佬的CSDN、博客园博客，惊叹于大佬的解题能力和刷题量，也包括很多大佬的学习笔记、随笔 blahblah，当时就想着什么时候咱也得整一个！ &emsp;&emsp;然鹅只恨自己太懒，大一下学期题几乎不刷题了，很少再去搜题解（了解到学院不参加ACM，觉得刷题失去意义）。大二虽然学院突然开始参加比赛了，但糟糕的时间安排和被各种破事占用时间，刷题都没得刷，更别提写博客了，于是博客计划无限期搁置。。。 &emsp;&emsp;2020的寒假意外得长，寒假前我还计划像以往假期一样每天早起去图书馆，然鹅疫情就这么来了，一切安排都被打乱。19年底我甚至计划20暑假去日本玩些日子，组了小伙伴也做了很多功课，但是照现在的情况来看，扶桑之旅多半是gg了。 &emsp;&emsp;大概4月底会开学吧，说实话宅家虽然没劲儿学，但我是一点不希望开学，原因是多方面的，仁者见仁智者见智就不细写了。不过考研和就业的临近确实让我提了点劲儿，我又开始刷题了，尽管依然菜得抠脚，但终于算是能静下心学习。目前的目标就是PAT甲级吧，原本3月考，因为疫情被延到了6月底，算是多给我几个月时间蹦跶哈哈哈哈。同时还在准备托福和N2，然鹅到现在也没见报名消息，难过。 &emsp;&emsp;为了整这个博客我牺牲了整整一个下午，从纠结Jekyll还是Hexo，到选主题拿不定主意，然后终于选定主题，字号配色又整不好了（整完提交上去排版崩了，又reset）。反正就是完美主义，一次次地推翻自己，不断的装了改、改了删、删了再装，没完没了，我还自己用Procreate手写了个Logo（丢人，估计过几天就得换），大概这也算是一种自虐？（笑） &emsp;&emsp;总而言之，希望自己能坚持下去，定期总结学习、总结生活（虽然语文丢人）。坚守自己21年暑假考日本的目标，趁着年轻再搏一搏，虽然软件行业好像不很重视学历，但考硕确实是实现名校情结的最后机会了！给我冲！頑張る","link":"/2020/04/01/hello-world/"},{"title":"使用分支限界法解决0/1背包问题","text":"&emsp;&emsp;在算法分析课上第一次接触分支限界法（Branch &amp; Bound），实验要求使用分支限界法解决 0/1 背包问题。虽然很清楚代码量要远高于 DP，但报告是还要写的，硬着头皮怼吧。随便在蓝桥杯题库找了一道 0/1 背包的基础题做测试，题目是算法训练的 ALGO-30 入学考试。 题目问题描述&emsp;&emsp;辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”&emsp;&emsp;如果你是辰辰，你能完成这个任务吗？ 输入格式&emsp;&emsp;第一行有两个整数T（1 &lt;= T &lt;= 1000）和M（1 &lt;= M &lt;= 100），用一个空格隔开，T 代表总共能够用来采药的时间，M代表山洞里的草药的数目。接下来的M行每行包括两个在 1 到 100 之间（包括1和100）的整数，分别表示采摘某株草药的时间和这株草药的价值。 输出格式&emsp;&emsp;包括一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。 样例输入123470 371 10069 11 2 样例输出13 数据规模和约定&emsp;&emsp;对于30%的数据，M &lt;= 10； &emsp;&emsp;对于全部的数据，M &lt;= 100。 解题思想分支限界法概述 &emsp;&emsp;分支限界法常以广度优先或以最小耗费（最大效益）优先的方式搜索问题的解空间树。&emsp;&emsp;在分支限界法中，每一个活结点只有一次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生其所有儿子结点。在这些儿子结点中，导致不可行解或导致非最优解的儿子结点被舍弃，其余儿子结点被加入活结点表中。&emsp;&emsp;此后，从活结点表中取下一结点成为当前扩展结点，并重复上述结点扩展过程。这个过程一直持续到找到所需的解或活结点表为空时为止。 &emsp;&emsp;对于0/1背包问题来说，就是每访问一个结点，生成两个儿子结点，一个是放入物品，一个是舍弃物品。在生成结点的同时判断该结点是否为可行解，并同时计算该结点下的上界。对于不可行解直接剪枝，可行结点使用优先队列存储。不断扩展队列优先级最高的结点，也就是上界最大的结点，当优先队列中优先级最高的结点上界不大于已知的值时，循环结束，当前得到的最优值即为所求最优值。 具体思路&emsp;&emsp;放到本题来看，每个草药包括两个属性：采集时间和价值。首先将所有草药按单位时间的价值从高到低排序，使用二叉树构造解空间树，每层结点代表正在放置第几个草药。由此，每个结点将能够扩展两个子节点，即放入 N 号草药和不放入 N 号草药。分别为每个扩展的结点计算上界，即计算规定时间内可拆分条件下的最大价值。如果当前结点的时间超出给定总时间 T 或者上界小于当前已知最优值，则剪枝处理，其余放入优先队列。 &emsp;&emsp;设定优先队列为大顶堆的数据结构，不断从优先队列中取出优先级最高（上界大于已知最优值）的结点，对其扩展。如果该结点已扩展至叶结点（所在路径已遍历所有草药），则与当前已知最优值比较，取最大值。当队列中所有结点的上界均不大于当前已知最优值时，循环结束。计算过程和解空间树如下图。 &nbsp;&nbsp;剪枝策略：采摘当前草药导致超时，或当前结点上界小于已知最优值时剪枝。 AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;using namespace std;struct Herb { int tim, val; // 时间，价值 bool operator &gt; (const Herb &amp;x) const { return (val * 1.0 / tim) &gt; (x.val * 1.0 / x.tim); }};struct Node { int nxt, sumT, sumV; // 下一药草的序号 当前总时间 当前总价值 double maxV; // 该结点的上界 bool operator &lt; (const Node &amp;x) const { return maxV &lt; x.maxV; // 优先队列内按上界从高到低排序 }};int T, M;vector&lt;Herb&gt; hrbs;priority_queue&lt;Node&gt; que;double bound(int i, int sumT, int sumV) { double res = sumV; int leftT = T - sumT; // 剩余时间 while (i &lt; M &amp;&amp; hrbs[i].tim &lt;= leftT) { // 在时间允许的条件下不断放入 leftT -= hrbs[i].tim; sumV += hrbs[i].val; i++; } if (i &lt; M) { res = sumV + leftT * (hrbs[i].val * 1.0 / hrbs[i].tim); } return res;}int solve() { int res = 0; Node r = {0, 0, 0, bound(0, 0, 0)}; que.push(r); // 放入根结点 while (que.top().maxV &gt; res) { // 堆顶结点的上界大于已知最优值 Node n = que.top(); que.pop(); if (n.nxt == M) { res = max(res, n.sumV); // 获取实际最优值 } else { Node n2 = n; // 复制一个 if (n.sumT + hrbs[n.nxt].tim &lt;= T) { // 超时剪掉 n.maxV = bound(n.nxt, n.sumT, n.sumV); // 放入当前草药时的上界 if (n.maxV &gt; res) { n.sumT += hrbs[n.nxt].tim; // 修改当前时间 n.sumV += hrbs[n.nxt].val; // 修改当前价值 n.nxt++; que.push(n); } } n2.maxV = bound(n2.nxt + 1, n2.sumT, n2.sumV); // 不放当前草药时的上界 if (n.maxV &gt; res) { // 上界小于当前已知最优值则剪枝 n2.nxt++; que.push(n2); } } } return res;}int main() { scanf(\"%d %d\", &amp;T, &amp;M); Herb h; for (int i = 0; i &lt; M; i++) { scanf(\"%d %d\", &amp;h.tim, &amp;h.val); hrbs.push_back(h); } sort(hrbs.begin(), hrbs.end(), greater&lt;Herb&gt;()); // 按单位时间价值排序 cout &lt;&lt; solve() &lt;&lt; endl;} 扯淡&emsp;&emsp;纯按自己的理解写的，所以不清楚代码是否规范。交上去顺利 AC 了，起初数据量较大的两个测试用例用了 15ms，后来稍微优化下全部 0ms 通过了。代码量有点大，不过效率比想象要高，其实还是 DP 效果好。算法思想是跟着油管的印度大叔 Abdul Bari 学的。视频地址：0/1 Knapsack using Branch and Bound","link":"/2020/05/22/01-knapsack-using-branch-n-bound/"},{"title":"Github+Coding双托管Hexo及自定义域名","text":"&emsp;&emsp;为了改善加载速度分别尝试了Coding和Gitee的托管以及CloudFlare的CDN加（减）速。无奈都不太乐观，倒是把博客同时托管在Coding，多了个备胎这样子。国内的CDN都要求必须备案，不想备案就只能走境外CDN或者只使用DNS解析。 &emsp;&emsp;心血来潮买了个域名，迫不及待把它绑定到博客。这个.me的黑山国家域名我还蛮喜欢，虽然觉得.cc更可爱些，但个人博客果然是.me比较合适（上面thumbnail是黑山的科托尔）。于是博客迎来全新域名 lokka.me。 使用Coding托管Hexo创建项目&emsp;&emsp;首先就是注册 Coding 账号，创建仓库，操作流程和Github一样，项目模板选择代码托管项目。项目名称随你，项目封面随你，其他的默认就好。Coding没要求必须公开源代码，README也可不添加。 &emsp;&emsp; 本地Hexo设置&emsp;&emsp;进入建好的仓库页面，复制页面右边提供的仓库SSH地址。 &emsp;&emsp; &emsp;&emsp;将SSH粘贴至Hexo的_config.yml对应位置，换行加上就行，注意格式。没错，加上Gitee三托管也可以的，喜欢就只管加上。下次hexo d的时候就会一起发布。 &emsp;&emsp; 添加SSH公钥&emsp;&emsp;为了方便发布，把之前搞GithubPages生成的SSH密钥添加到Coding，SSH密钥一般藏在下面这个位置。 C:\\Users\\用户名\\.ssh\\id_rsa.pub &emsp;&emsp;在Coding页面右上角的弹框里找到 个人设置，然后添加 SSH公钥，复制粘贴确认即可。之后使用hexo d发布时会需要确认，直接回复yes。 静态页面部署&emsp;&emsp;Hexo生成的静态网页成功发布到Coding仓库后进入项目页面，页面左下角找到项目设置 -&gt; 项目与成员 -&gt; 功能开关，然后打开 持续集成 和 持续部署（部署静态页面必须项）。 &emsp;&emsp; &emsp;&emsp;开启上述两项功能后，回到项目主页，左边目录多了持续集成和持续部署两个选项，找到 静态网站，点击立即部署即可。Coding会自动生成一个地址（我看网上别人的都是coding.me的域名，可能现在改版就没了），然后就发布成功啦!点开那个丑陋的地址看看吧！ &emsp;&emsp; 自定义域名&emsp;&emsp;CodingPages生成的域名实在不能接受，赶！紧！买！域！名！ 购买域名&emsp;&emsp;年幼无知的我没做足功课就把第一次献给了 GoDaddy，在这里建议萌新在购买域名前，一定要先在 domcomp 查询一下，这里可以查到你喜欢的域名的最便宜价格及提供该价格的注册商，也可以顺便选一下顶级域名。除了GoDaddy外，部分注册商如 dynadot 也是支持支付宝的。 &emsp;&emsp;由于我是之后才知道domcomp的，已经在GoDaddy买过了。购买流程就是选域名，加购物车，然后结账时候顺便注册账号，选择支付宝，掏出手机扫码付款，按提示来就vans了。GoDaddy的隐私保护是收费的，如果不购买的话，查询whois是可以看到你姓名、电话和邮箱的。不怕信息公开当然可以不买，但是有些注册商比如Porkbun、Dynadot、NameSilo、NameCheap等等一般会免费赠送隐私保护。GoDaddy这里每年除了续费贵，隐私保护也是按年交的，当然不差钱就无所谓啦。 绑定域名&emsp;&emsp;购买成功后找到购买的域名，点击 DNS管理，配置CNAME记录值为CodingPages的地址,CNAME名称填 @ 就好。如果想解析到GithubPages，同理。 &emsp;&emsp;配置完成后回到Coding，在静态网站中找到设置，在 绑定新域名 处添加域名，如果你没有配置DNS是会提示申请证书失败的。另外由于网站是由Coding或Github托管的，所以不需要备案，正确配置CNAME即可。待证书状态显示 正常 就绑定成功了，用新域名访问博客吧！ CloudFlare域名解析&emsp;&emsp;上一步GoDaddy的DNS我们可以不用，可直接省略。使用CloudFlare解析域名，顺便蹭一蹭免费CDN。账号注册成功后，点击添加站点（会自动弹出），然后输入要使用的域名，之后CloudFlare会提供两个NS地址，要求在域名注册商那里修改NS地址。 &emsp;&emsp;回到GoDaddy，进入域名管理，修改域名服务器，把CloudFlare提供的两个NS地址粘贴进去，然后确认，之后会显示：我们无法显示您的DNS信息，因为您的域名服务器不是由我们管理的。 OK，没GoDaddy啥事儿了。 &emsp;&emsp; &emsp;&emsp;返回CloudFlare后点击检查名称服务器（忘了具体名称了，看页面提示就行），然后会提示在排队等待检查。修改DNS后需要等一会CloudFlare才有反应。 &emsp;&emsp;域名在CloudFlare这边添加成功后，点击域名进入域名管理界面，找到 DNS 配置CNAME。其中小云朵标志代表开启CDN加速，如果你网站的主要访客来自境外，那么建议开启，橙色代表开启。国内的话就关闭吧，速度比Github还慢。所以这个CDN加速与国内无缘，关掉后只使用域名解析。（我郑州联通，ping GithubPages的地址只有100ms出头的延迟，走CDN居然飙到将近300ms？？CloudFlare对国内真的不友好） &emsp;&emsp;Coding和Github都有免费提供SSL证书的，自定义域名后直接在设置页面开启 强制HTTPS 就好，Github在自定义域名后会自动申请证书。此外也可以找CloudFlare申请证书。域名管理页面找到 SSL/TLS，确认SSL/TLS加密模式为完全，一般默认就是。 &emsp;&emsp; &emsp;&emsp;之后在 边缘证书 栏目找到 始终使用HTTPS，确认该项为开启状态。之后就慢慢等吧，CloudFlare会在24小时内为域名颁发证书。 &emsp;&emsp; 阿里云域名解析&emsp;&emsp;为了实现国内走Coding，国外走Github，可以选择用阿里云的DNS解析（腾讯云也差不多，都一样的东西）。流程跟CloudFlare一样，账号注册完成后，在主页找到控制台 -&gt; 域名 -&gt; 进入域名解析列表 -&gt; 添加域名，然后回到域名注册商，改成下面阿里云的两个DNS，稍等几分钟就OK了。 ns1.alidns.comns2.alidns.com &emsp;&emsp;域名添加成功后，为Github和Coding的博客分别添加CNAME记录，默认解析到Coding，境外解析到Github。 &emsp;&emsp; 总结&emsp;&emsp;这一波折腾完觉得自己知识面真的太窄，一开始想贪CloudFlare的免费CDN，就去用他的DNS解析，结果是反向加速，GithubPages被闲置，域名只解析到CodingPages。用国内的CDN是需要备案的，想到CloudFlare的CDN是反向加速，也没什么好抱怨了（主要还是懒得备案）。 &emsp;&emsp;我还尝试了GiteePages，速度蛮快的，毕竟国内阿里云，Ping一下全国都深绿的，有条件的用Gitee托管效果应该不错。搭建流程跟GithubPages一样，项目名称使用用户名能开启 XXX.gitee.io的地址，否则地址末尾会包含项目名。但是Gitee很抠，升级pro版才能自定义域名和自动部署，而且普通版每次发布后还要手动更新。Pro版每年99元，新用户有1个月的免费体验，我试了下，配置证书的时候出了问题，Gitee要求粘贴域名证书和密钥，没整成（可能是我太笨），如果你搞定了一定要告诉我，不胜感激！ &emsp;&emsp;CodingPages用的新加坡的腾讯云，延迟和加载速度肯定比不了Gitee，但比直接GithubPages肯定强多了，ping一下我觉得延迟还行吧，郑州联通大概80+的延迟，具体分时段，加载速度还算能接受。具体如何选择还是看个人吧。 &emsp;&emsp;PS：每次Hexo发布会自动覆盖CNAME文件，如果是直接在Github仓库加的CNAME文件，每次发布后自定义域名会失效，解决办法是把CNAME文件放入Hexo的source文件夹。 unsplash-logoPolina Rytova","link":"/2020/04/27/coding-pages-n-custom-domain/"},{"title":"N皇后（N-Queens）","text":"LeetCode 51 N-Queens LeetCode 52 N-Queens II Lanqiao BASIC-27 2N-Queens Lanqiao ADV-203 8-Queens PAT-A 1128 N-Queens Puzzle N-Queens Description &emsp;&emsp;n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 &emsp;&emsp; &emsp;&emsp;上图为 8 皇后问题的一种解法。 &emsp;&emsp;给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。 &emsp;&emsp;每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。 &emsp;&emsp;原题：LeetCode 51 N-Queens Sample 123456789101112131415输入: 4输出: [ [&quot;.Q..&quot;, // 解法 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, // 解法 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;]]解释: 4 皇后问题存在两个不同的解法。 Thought &emsp;&emsp;题目要求将n个皇后放置在n * n大小的棋盘上，皇后之间不能打架，也就是每行、每列、每条对角线上不能同时有两位皇后。 &emsp;&emsp;思路就是深搜回溯，从第1行开始每次逐列放置皇后，每次放置时对已经放置完成的行进行判断，能放则放，不能放则弃。也就是检查当前位置皇后的上、左上、右上方是否存在皇后。完成n个皇后放置任务后将当前棋盘添加至结果集。 Code 1 &emsp;&emsp;觉得这题难度其实不大，就是个人在效率上有点难受（再见残酷的世界！），第1版写完交上去虽然一次AC了，但时间和空间居然都被95%的人碾压？？？（拐回来看代码发现参数全是形参，改了引用参数后时间击败60%空间击败100%）然后参考老哥们的题解改了改，还凑合吧，粘两个版本留念。 &emsp;&emsp;直接把整个棋盘开出来了，然后逐行放置皇后。检查已放置的行就开了3个for循环，分别对正上、左上、右上的格子进行遍历判断。 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution {public: bool isValid(vector&lt;string&gt;&amp; bd, int row, int col) { //正上 for(int i = 0; i &lt; row; i++) { if(bd[i][col] == 'Q') return false; } //左上 for(int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--) { if(bd[i][j] == 'Q') return false; } //右上 for(int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; bd.size(); i--, j++) { if(bd[i][j] == 'Q') return false; } return true; } void dfs(vector&lt;string&gt;&amp; bd, int row, int n) { if(row == n) { res.push_back(bd); return; } for(int i = 0; i &lt; n; i++) { if(isValid(bd, row, i)) { bd[row][i] = 'Q'; dfs(bd, row + 1, n); bd[row][i] = '.'; } } } vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) { vector&lt;string&gt; bd(n, string(n, '.')); dfs(bd, 0, n); return res; }private: vector&lt;vector&lt;string&gt;&gt; res;}; Code 2 &emsp;&emsp;棋盘是按行开辟的，凑够一整盘后带走放入结果集（空间上没有影响，就是单纯尝试下。。。） &emsp;&emsp;这个判断比较有意思，是在题解区学的。先开个数组用来存放棋盘每一行放置皇后的列值，在判断时，如果当前列与数组中的列重复，即正上方有皇后。对角线点坐标的x, y与当前点相减的绝对值是相同的，由此判断对角线上是否存在皇后。 123456789101112131415161718192021222324252627282930313233343536373839class Solution {public: bool isValid(int row, int col, vector&lt;int&gt; &amp;pos) { for (int i = 0; i &lt; row; i++) { if (col == pos[i] || abs(row - i) == abs(pos[i] - col)) return false; } return true; } void dfs(int row, int n, vector&lt;int&gt; &amp;pos, string &amp;line) { if (row == n) { res.push_back(tmp); return; } for (int i = 0; i &lt; n; i++) { if (isValid(row, i, pos)) { line[i] = 'Q'; tmp.push_back(line); line[i] = '.'; pos[row] = i; dfs(row + 1, n, pos, line); pos[row] = -1; tmp.pop_back(); } } } vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) { string line(n, '.'); vector&lt;int&gt; pos(n, -1); dfs(0, n, pos, line); return res; }private: vector&lt;vector&lt;string&gt;&gt; res; vector&lt;string&gt; tmp;}; N-Queen II Description &emsp;&emsp;n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 &emsp;&emsp;&emsp;&emsp; &emsp;&emsp;上图为 8 皇后问题的一种解法。 &emsp;&emsp;给定一个整数 n，返回 n 皇后不同的解决方案的数量。 &emsp;&emsp;原题：LeetCode 52 N-Queens II Sample 12345678910111213141516输入: 4输出: 2解释: 4 皇后问题存在如下两个不同的解法。[ [&quot;.Q..&quot;, // 解法 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, // 解法 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;]] Thought &emsp;&emsp;怎么说呢，我严重怀疑LeetCode的临时工把题号标错了，这个虽然是II，但明显是原版的简化。看见题就没多想，直接复制粘贴上一题代码，删掉所有棋盘数据，只保留存放每行皇后位置的数组，跑都没跑就提交了（也就这时候敢浪）。在题解区看到用位运算好像效率蛮高的，改（有）天（缘）再看吧。 Code 12345678910111213141516171819202122232425262728293031class Solution {public: bool isValid(int row, int col, vector&lt;int&gt; &amp;pos) { for (int i = 0; i &lt; row; i++) { if (col == pos[i] || abs(row - i) == abs(pos[i] - col)) return false; } return true; } void dfs(int row, int n, vector&lt;int&gt; &amp;pos, int &amp;res) { if (row == n) { res++; return; } for (int i = 0; i &lt; n; i++) { if (isValid(row, i, pos)) { pos[row] = i; dfs(row + 1, n, pos, res); pos[row] = -1; } } } int totalNQueens(int n) { vector&lt;int&gt; pos(n, -1); int res = 0; dfs(0, n, pos, res); return res; }}; 2N-Queens Description &emsp;&emsp;给定一个n*n的棋盘，棋盘中有一些位置不能放皇后。现在要向棋盘中放入n个黑皇后和n个白皇后，使任意的两个黑皇后都不在同一行、同一列或同一条对角线上，任意的两个白皇后都不在同一行、同一列或同一条对角线上。问总共有多少种放法？n小于等于8。 Input: &emsp;&emsp;输入的第一行为一个整数n，表示棋盘的大小。 &emsp;&emsp;接下来n行，每行n个0或1的整数，如果一个整数为1，表示对应的位置可以放皇后，如果一个整数为0，表示对应的位置不可以放皇后。 Output: &emsp;&emsp;输出一个整数，表示总共有多少种放法。 Sample 12345678910111213141516171819输入: // Sample 141 1 1 11 1 1 11 1 1 11 1 1 1输出:2输入: // Sample 241 0 1 11 1 1 11 1 1 11 1 1 1输出:0 Thought &emsp;&emsp;和N皇后的思路一样，区别是放置两种颜色的皇后，也就是黑白皇后各来一次深搜。根据题意，棋盘上1代表可以放置，0代表不可放置。用2表示白皇后，用3表示黑皇后。放置白皇后时遇到0跳过，放置黑皇后时遇到0和2跳过，两种颜色全部放完时（q == 4)结束并计数。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;int n, bd[10][10], res = 0;bool isValid(int row, int col, int q) { // q 为皇后类型 for (int r = row - 1, t = 1; r &gt;= 0; r--, t++ ) { if (bd[r][col] == q || (col - t &gt;= 0 &amp;&amp; bd[r][col - t] == q) || (col + t &lt; n &amp;&amp; bd[r][col + t] == q)) { return false; } } return true;}void dfs(int row, int q) { if (q == 4) { // 黑白皇后均已放完 res++; return; } else if (row == n) { dfs(0, q + 1); // 放置另一种颜色的皇后 return; } for (int col = 0; col &lt; n; col++) { if (bd[row][col] == 0 || bd[row][col] == 2) continue; if (isValid(row, col, q)) { bd[row][col] = q; dfs(row + 1, q); bd[row][col] = 1; } }}int main() { scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) scanf(\"%d\", &amp;bd[i][j]); dfs(0, 2); cout &lt;&lt; res &lt;&lt; endl;} 8-Queens Description &emsp;&emsp;规则同8皇后问题，但是棋盘上每格都有一个数字，要求八皇后所在格子数字之和最大。 Input: &emsp;&emsp;一个8*8的棋盘。 Ouput: &emsp;&emsp;所能得到的最大数字和 Sample 1234567891011121314输入:1 2 3 4 5 6 7 89 10 11 12 13 14 15 1617 18 19 20 21 22 23 2425 26 27 28 29 30 31 3233 34 35 36 37 38 39 4041 42 43 44 45 46 47 4848 50 51 52 53 54 55 5657 58 59 60 61 62 63 64输出:260数据规模和约定: 棋盘上的数字范围 0~99 Thought &emsp;&emsp;依然是深搜回溯，各个位置的数字已经给了，并且题目说明了数字范围为0~99，所以我们将访问的数字累加，并将值改为-1表示已经访问过，确保不被重复访问。每次满足终止条件时，比较当前放置方法的数字之和，取最大值即可。 Code 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;int n = 8, bd[10][10], res = 0;bool isValid(int row, int col) { for (int r = row - 1, t = 1; r &gt;= 0; r--, t++ ) { if (bd[r][col] == -1 || (col - t &gt;= 0 &amp;&amp; bd[r][col - t] == -1) || (col + t &lt; n &amp;&amp; bd[r][col + t] == -1)) { return false; } } return true;}void dfs(int row, int sum) { if (row == n) { res = max(res, sum); return; } for (int col = 0; col &lt; n; col++) { if (isValid(row, col)) { int tmp = bd[row][col]; bd[row][col] = -1; dfs(row + 1, sum + tmp); bd[row][col] = tmp; } }}int main() { for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) scanf(\"%d\", &amp;bd[i][j]); dfs(0, 0); cout &lt;&lt; res &lt;&lt; endl;} N Queens Puzzle Description The “eight queens puzzle” is the problem of placing eight chess queens on an 8 × 8 chessboard so that no two queens threaten each other. Thus, a solution requires that no two queens share the same row, column, or diagonal. The eight queens puzzle is an example of the more general N queens problem of placing N non-attacking queens on an N×N chessboard. (From Wikipedia - “Eight queens puzzle”.) Here you are NOT asked to solve the puzzles. Instead, you are supposed to judge whether or not a given configuration of the chessboard is a solution. To simplify the representation of a chessboard, let us assume that no two queens will be placed in the same column. Then a configuration can be represented by a simple integer sequence (Q​1, Q2, ⋯, Q​N), where Qi is the row number of the queen in the i-th column. For example, Figure 1 can be represented by (4, 6, 8, 2, 7, 1, 3, 5) and it is indeed a solution to the 8 queens puzzle; while Figure 2 can be represented by (4, 6, 7, 2, 8, 1, 9, 5, 3) and is NOT a 9 queens’ solution. Input Specification Each input file contains several test cases. The first line gives an integer K (1&lt;K≤200). Then K lines follow, each gives a configuration in the format “N Q1 Q2 … QN”, where 4≤N≤1000 and it is guaranteed that 1≤Qi≤N for all i=1,⋯,N. The numbers are separated by spaces. Output Specification For each configuration, if it is a solution to the N queens problem, print YES in a line; or NO if not. Sample Input 1234548 4 6 8 2 7 1 3 59 4 6 7 2 8 1 9 5 36 1 5 2 6 4 35 1 3 5 2 4 Sample Output 1234YESNONOYES 原题：PAT-A N Queens Puzzle Thought 直接暴力就Vans了，为了方便思考将棋盘顺时针反转90度。输入的过程理解成逐行放置皇后的过程。以Figure 1为例，输入皇后位置分别为第1行第4列，第2行第6列… 每输入一个数字（每放置一个皇后）就遍历之前的所有行，检查是否有同列或者同对角线的。 Code 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(0); int K; cin &gt;&gt; K; while(K--) { int N, t, flag = 1; cin &gt;&gt; N; vector&lt;int&gt; vec; for (int i = 0; i &lt; N; i++) { cin &gt;&gt; t; vec.push_back(t); int l = t - 1, r = t + 1; for (int j = i - 1; j &gt;= 0 &amp;&amp; flag; j--) { if (vec[j] == t || vec[j] == l || vec[j] == r) { flag = 0; } l--, r++; } } cout &lt;&lt; (flag ? \"YES\" : \"NO\") &lt;&lt; endl; }} Summary&emsp;&emsp;总得来说就是简单的暴力深搜回溯，逻辑上没什么细节好抠的。虽然LeetCode标记的难度是Hard，但实际其实还好？不过第一次信心满满地交上去，结果时间和空间都只击败5%真的难受（弱鸡枯了），确实自己经常粗心忘打取地址符，导致内存使用翻倍，尤其是变量名很长的时候都是习惯性复制粘贴，就忘了。 &emsp;&emsp;蓝桥的比LeetCode难度稍大，比较有意思的是蓝桥的2N皇后被放在“基础练习”的试题集，而相较而言更简单的8皇后被放在“算法提高”？？？可能跟LeetCode是同一个临时工吧哈哈哈哈。 unsplash-logoMichał Parzuchowski","link":"/2020/04/08/n-queens/"},{"title":"解决MacOS Clion引用 <bits/stdc++.h> 问题","text":"&nbsp;&nbsp;MacOS默认使用Clang，没有bits/stdc++.h，需要手动添加 在 Clion -&gt; Preferences -&gt; Build -&gt; Toolchains 查看 C++ Compiler 的路径，如下图所示。 1cd /library/developer/commandlinetools/usr cd 至 /usr 即可，在该目录下找到include文件夹，在该文件夹内创建 bits 文件夹，然后把下面的 stdc++.h 拖入文件夹即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116// C++ includes used for precompiling -*- C++ -*-// Copyright (C) 2003-2014 Free Software Foundation, Inc.//// This file is part of the GNU ISO C++ Library. This library is free// software; you can redistribute it and/or modify it under the// terms of the GNU General Public License as published by the// Free Software Foundation; either version 3, or (at your option)// any later version.// This library is distributed in the hope that it will be useful,// but WITHOUT ANY WARRANTY; without even the implied warranty of// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the// GNU General Public License for more details.// Under Section 7 of GPL version 3, you are granted additional// permissions described in the GCC Runtime Library Exception, version// 3.1, as published by the Free Software Foundation.// You should have received a copy of the GNU General Public License and// a copy of the GCC Runtime Library Exception along with this program;// see the files COPYING3 and COPYING.RUNTIME respectively. If not, see// &lt;http://www.gnu.org/licenses/&gt;./** @file stdc++.h * This is an implementation file for a precompiled header. */// 17.4.1.2 Headers// C#ifndef _GLIBCXX_NO_ASSERT#include &lt;cassert&gt;#endif#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;ciso646&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;cmath&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#if __cplusplus &gt;= 201103L#include &lt;ccomplex&gt;#include &lt;cfenv&gt;#include &lt;cinttypes&gt;#include &lt;cstdbool&gt;#include &lt;cstdint&gt;#include &lt;ctgmath&gt;#include &lt;cwchar&gt;#include &lt;cwctype&gt;#endif// C++#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;complex&gt;#include &lt;deque&gt;#include &lt;exception&gt;#include &lt;fstream&gt;#include &lt;functional&gt;#include &lt;iomanip&gt;#include &lt;ios&gt;#include &lt;iosfwd&gt;#include &lt;iostream&gt;#include &lt;istream&gt;#include &lt;iterator&gt;#include &lt;limits&gt;#include &lt;list&gt;#include &lt;locale&gt;#include &lt;map&gt;#include &lt;memory&gt;#include &lt;new&gt;#include &lt;numeric&gt;#include &lt;ostream&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;stack&gt;#include &lt;stdexcept&gt;#include &lt;streambuf&gt;#include &lt;string&gt;#include &lt;typeinfo&gt;#include &lt;utility&gt;#include &lt;valarray&gt;#include &lt;vector&gt;#if __cplusplus &gt;= 201103L#include &lt;array&gt;#include &lt;atomic&gt;#include &lt;chrono&gt;#include &lt;condition_variable&gt;#include &lt;forward_list&gt;#include &lt;future&gt;#include &lt;initializer_list&gt;#include &lt;mutex&gt;#include &lt;random&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;scoped_allocator&gt;#include &lt;system_error&gt;#include &lt;thread&gt;#include &lt;tuple&gt;#include &lt;typeindex&gt;#include &lt;type_traits&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#endif","link":"/2020/08/25/include-bits-stdc-in-clion/"},{"title":"Lanqiao-2018-CB省赛 测试次数","text":"&nbsp;&nbsp;第九届蓝桥杯省赛填空题，动态规划。 x星球的居民脾气不太好，但好在他们生气的时候唯一的异常举动是：摔手机。各大厂商也就纷纷推出各种耐摔型手机。x星球的质监局规定了手机必须经过耐摔测试，并且评定出一个耐摔指数来，之后才允许上市流通。 x星球有很多高耸入云的高塔，刚好可以用来做耐摔测试。塔的每一层高度都是一样的，与地球上稍有不同的是，他们的第一层不是地面，而是相当于我们的2楼。 如果手机从第7层扔下去没摔坏，但第8层摔坏了，则手机耐摔指数=7。特别地，如果手机从第1层扔下去就坏了，则耐摔指数=0。如果到了塔的最高层第n层扔没摔坏，则耐摔指数=n 为了减少测试次数，从每个厂家抽样3部手机参加测试。 某次测试的塔高为1000层，如果我们总是采用最佳策略，在最坏的运气下最多需要测试多少次才能确定手机的耐摔指数呢？ 请填写这个最多测试次数。 注意：需要填写的是一个整数，不要填写任何多余内容。 Analysis&emsp;&emsp;首先对于一个手机，要测试耐摔指数只能一层一层挨着摔，所以当手机数量为 1 时，测试次数为层数。 &emsp;&emsp;这题的坑在于 最佳策略和最坏运气，只能在最后一个手机测出耐摔指数，也就是子问题要多摔，原问题尽可能少摔。摔第 m 个手机时，在第 k 层的情况可划分为两个子问题，即摔坏和没摔坏，两个子问题取测试次数最多的（最坏运气）；原问题取测试次数最少的。在第 k 层摔坏即上个手机在 [0, k-1] 内摔坏，在第 k 层没摔坏即当前手机在 [k + 1, 1000] 摔坏，也就是剩余的层数。 Code1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;// dp[m][f] 表示 m 个手机, f 层时的最多测试次数int dp[5][1005];int main() { // M: Mobile, F: Floor int M = 3, F = 1000; // 一个手机时，测试次数等于层数 for (int f = 1; f &lt;= F; f++) { dp[1][f] = f; } for (int m = 2; m &lt;= M; m++) { for (int f = 2; f &lt;= F; f++) { dp[m][f] = INT_MAX; // 当前手机数量和层数下，获取最少测试次数 for (int k = 2; k &lt;= f; k++) { // 在第 k 层，原问题划分为当前手机摔坏和没摔坏两个子问题，子问题取测试次数最多的 // 摔坏了则上个手机在[1, k-1]摔坏，没摔坏则当前手机在[k+1, 1000]摔坏，同时测试次数 +1 dp[m][f] = min(dp[m][f], max(dp[m - 1][k - 1], dp[m][f - k]) + 1); } } } cout &lt;&lt; dp[3][1000];} Tsukkomi&emsp;&emsp;18 年省赛时候没学过 DP 就没写出来，后来也没再写过。昨天有学弟问我会不会，浏览一遍题还是不会。。。一大早起床就在网上搜题解，总算是有点感觉了。","link":"/2020/08/25/lanqiao-2018cb-4/"},{"title":"PAT-A 1081 Rational Sum (20)","text":"&nbsp;&nbsp;记录一次被水题的测试点教做人的经历，果然还是差得远。 Given N rational numbers in the form numerator/denominator, you are supposed to calculate their sum. Problem:&nbsp;PAT-A 1081 Rational Sum Input SpecificationEach input file contains one test case. Each case starts with a positive integer N (≤100), followed in the next line N rational numbers a1/b1 a2/b2 … where all the numerators and denominators are in the range of long int. If there is a negative number, then the sign must appear in front of the numerator. Output SpecificationFor each test case, output the sum in the simplest form integer numerator/denominator where integer is the integer part of the sum, numerator &lt; denominator, and the numerator and the denominator have no common factor. You must output only the fractional part if the integer part is 0. Sample Input 11252/5 4/15 1/30 -2/60 8/3 Sample Output 113 1/3 Sample Input 21224/3 2/3 Sample Output 212 Sample Input 31231/3 -1/6 1/8 Sample Output 317/24 Analysis&emsp;&emsp;简单的分数加法运算，需要对分数进行化简，即计算最大公约数。测试点只有5个，虽然没有涉及分母为0的情况，但对输出格式抠得还是很死的。输出格式有以下几种。 整数部分为0，分子部分不为0，输出分数 整数部分不为0，分子部分为0，输出整数 整数部分不为0，分子部分不为0，输出整数 + 分数 整数部分和分子部分均为0，输出一个0 &nbsp;&nbsp;两个分数相加时会出现溢出，long long不够用，需要先化简。 Code12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;int gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b);}int main() { int N, num, numS = 0, den, denS = 1; scanf(\"%d\", &amp;N); for (int i = 0; i &lt; N; i++) { scanf(\"%d/%d\", &amp;num, &amp;den); numS = numS * den + denS * num; denS = denS * den; int t = gcd(abs(numS), abs(denS)); numS /= t; denS /= t; } int itg = numS / denS; // 获得整数部分 numS %= denS; if (itg != 0) { printf(\"%d\", itg); // 输出非 0 整数部分 if (numS == 0) return 0; // 分子为 0, 结束 printf(\" \"); } if (numS == 0) { // 整数, 分子均为 0 printf(\"0\"); } else { // 分子不为零 printf(\"%d/%d\", numS, denS); }} Tsukkomi&emsp;&emsp;一开始写的时候没有划清4种输出格式，代码写得很乱，拆东墙补西墙，就完全自己挖坑往里跳。后来受不了了直接重写了输出部分，重新理一遍写出来交上去，始终就有一个测试点过不了。 &emsp;&emsp;起初我的循环部分是下面这么写的，一直有一个测试点通过不能，核对了半天输出格式，编了各种测试用例都没问题，每次交上去就是有一个不过。网上搜别人的核对后确认输出都是正确的，然后才想到是不是溢出了。给第一个输入的分数添加了化简操作，就过了…… 12345678910ll num, numS, den, denS;scanf(\"%d %lld/%lld\", &amp;N, &amp;numS, &amp;denS);for (int i = 1; i &lt; N; i++) { scanf(\"%lld/%lld\", &amp;num, &amp;den); numS = numS * den + denS * num; denS *= den; t = gcd(abs(numS), abs(denS)); numS /= t; denS /= t;}","link":"/2020/05/26/pat-a-1081/"},{"title":"PAT-A 1148 Werewolf - Simple Version (20)","text":"&nbsp;&nbsp;狼人杀简单版，暴力枚举 Werewolf（狼人杀） is a game in which the players are partitioned into two parties: the werewolves and the human beings. Suppose that in a game, player #1 said: “Player #2 is a werewolf.”; player #2 said: “Player #3 is a human.”; player #3 said: “Player #4 is a werewolf.”; player #4 said: “Player #5 is a human.”; and player #5 said: “Player #4 is a human.”. Given that there were 2 werewolves among them, at least one but not all the werewolves were lying, and there were exactly 2 liars. Can you point out the werewolves? Now you are asked to solve a harder version of this problem: given that there were N players, with 2 werewolves among them, at least one but not all the werewolves were lying, and there were exactly 2 liars. You are supposed to point out the werewolves. Problem:&nbsp;PAT-A 1148 Werewolf - Simple Version Input SpecificationEach input file contains one test case. For each case, the first line gives a positive integer N (5 ≤ N ≤ 100). Then N lines follow and the i-th line gives the statement of the i-th player (1 ≤ i ≤ N), which is represented by the index of the player with a positive sign for a human and a negative sign for a werewolf. Output SpecificationIf a solution exists, print in a line in ascending order the indices of the two werewolves. The numbers must be separated by exactly one space with no extra spaces at the beginning or the end of the line. If there are more than one solution, you must output the smallest solution sequence – that is, for two sequences A=a[1],…,a[M] and B=b[1],…,b[M], if there exists 0 ≤ k &lt; M such that a[i] = b[i] (i ≤ k) and a[k+1]&lt;b[k+1], then A is said to be smaller than B. In case there is no solution, simply print No Solution. Sample Input 11234565-2+3-4+5+4 Sample Output 111 4 Sample Input 212345676+6+3+1-5-2+4 Sample Output 211 5 Sample Input 31234565-2-3-4-5-1 Sample Output 31No Solution Analysis题目划重点： N 个玩家中有 2 个狼人 至少 1 个狼人说谎 不是所有狼人都说谎 有 2 个玩家说谎 &emsp;&emsp;也就是说，说谎的 2 个玩家中 1 个狼人 1 个人类。题目要求输出 2 个狼人的序号，因此枚举所有可能的 2 个狼人的组合，检查该组合下的说谎玩家数及身份，如果恰为 2 个玩家说谎且 1 个狼人 1 个人类，即为所求解。 Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(0); int N; cin &gt;&gt; N; vector&lt;int&gt; vec(N + 1); for (int i = 1; i &lt;= N; i++) { cin &gt;&gt; vec[i]; } // 枚举所有可能的狼人组合 for (int i = 1; i &lt;= N; i++) { for (int j = i + 1; j &lt;= N; j++) { // sign记录身份，liar保存说谎者 vector&lt;int&gt; sign(N + 1, 1), liar; // 假设 i, j为狼人 sign[i] = sign[j] = -1; // 自己说的与事实不符，记为说谎者 for (int k = 1; k &lt;= N; k++) { if (sign[abs(vec[k])] * vec[k] &lt; 0) { liar.push_back(k); } } // 说谎者数量为 2，且 1 狼人 1 人类，则 i, j为狼人成立 if (liar.size() == 2 &amp;&amp; sign[liar[0]] * sign[liar[1]] &lt; 0) { cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; j &lt;&lt; endl; return 0; } } } cout &lt;&lt; \"No Solution\" &lt;&lt; endl;} Tsukkomi&emsp;&emsp;没有读清题就开始写了，半路才发现说谎的玩家中1个狼人1个人类。想着能不能用什么巧妙的方法得出结果，无奈太笨。网上搜了搜大佬的解法才知道直接暴力枚举就 vans 了。","link":"/2020/07/02/pat-a-1148/"},{"title":"PAT-A 1003 Emergency (25)","text":"&nbsp;&nbsp;图的 Dijkstra 算法，在算法基础上增加最大点权和以及最短路径条数的记录。 As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible. Problem:&nbsp;PAT-A 1003 Emergency Input SpecificationEach input file contains one test case. For each test case, the first line contains 4 positive integers: N (≤ 500) - the number of cities (and the cities are numbered from 0 to N − 1), M - the number of roads, $C_1$ and $C_2$ - the cities that you are currently in and that you must save, respectively. The next line contains N integers, where the i-th integer is the number of rescue teams in the i-th city. Then M lines follow, each describes a road with three integers $c_​1$, $c_2$ and L, which are the pair of cities connected by a road and the length of that road, respectively. It is guaranteed that there exists at least one path from $C_​1$ to $C_2$. Output SpecificationFor each test case, print in one line two numbers: the number of different shortest paths between $C_1$ and $C_2$, and the maximum amount of rescue teams you can possibly gather. All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line. Sample Input123456785 6 0 21 2 1 5 30 1 10 2 20 3 11 2 12 4 13 4 1 Sample Output12 4 Analysis&emsp;&emsp;单源最短路径问题，用 Dijkstra 算法。根据题意，每个城市的救援队数量为点权，城市之间的距离为边权。由于题目要求输出结果为最短路径数和最大点权和，添加 num 数组记录起点至各顶点的最短路径数，添加 w 数组记录起点至各个顶点的最大点权和，在计算 d 的同时更新上述两个数组，详情见代码注释。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;const int mxN = 505;// N:顶点数, M:边数, C1:起点, C2:终点int N, M, C1, C2;// G:邻接矩阵, d:起点至各点的最短距离, weight:点权, w:最大点权和, num:最短路径条数int G[mxN][mxN], d[mxN], weight[mxN], w[mxN], num[mxN];bool vis[mxN] = {false};void dijkstra(int s) { // s 为起点 fill(d, d + N, INT_MAX); // 初始化 d 数组 d[s] = 0; // 起点到自身距离为 0 w[s] = weight[s]; // 起点最大点权 num[s] = 1; // 起点至起点路径数为 1 for (int i = 0; i &lt; N; i++) { int u = -1, MIN = INT_MAX; // 遍历 N 个点, 寻找最小 d[]和对应顶点 for (int j = 0; j &lt; N; j++) { if (!vis[j] &amp;&amp; d[j] &lt; MIN) { MIN = d[j]; u = j; } } if (u == -1) return; // 未找到通路，剩下的顶点与起点不通 vis[u] = true; // 标记 u 已访问 for (int v = 0; v &lt; N; v++) { // 如果 v 未访问, 且 u - v 连通 if (!vis[v] &amp;&amp; G[u][v] != INT_MAX) { // 如果以 u 为中介点至 v 的距离小于已知 d[v] if (d[u] + G[u][v] &lt; d[v]) { d[v] = d[u] + G[u][v]; // 更新 d[v] w[v] = w[u] + weight[v]; // 更新点权和 num[v] = num[u]; // 更新路径数 } else if (d[u] + G[u][v] == d[v]) { // 路径长度相同 w[v] = max(w[v], w[u] + weight[v]); // 比较获取最大点权 num[v] += num[u]; // 路径数累加 } } } }}int main() { ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; N &gt;&gt; M &gt;&gt; C1 &gt;&gt; C2; // 读入点权, 即每个城市的救援队数量 for (int i = 0; i &lt; N; i++) { cin &gt;&gt; weight[i]; } // 初始化图 G, 边权为无穷大 fill(G[0], G[0] + mxN * mxN, INT_MAX); // 读入边权, 即每两个城市的距离, 无向图双向赋值 for (int i = 0; i &lt; M; i++) { int u, v, l; cin &gt;&gt; u &gt;&gt; v &gt;&gt; l; G[u][v] = G[v][u] = l; } dijkstra(C1); cout &lt;&lt; num[C2] &lt;&lt; \" \" &lt;&lt; w[C2] &lt;&lt; endl;} Tsukkomi&emsp;&emsp;Dijkstra 基本快忘了，思想是明白的，但写出来有点费劲。之前用到的时候也是直接比着模板写的，但为了准备 PAT 考试，就硬学呗。代码参考了胡凡的《算法笔记》，书上正好有这道题的讲解，很是详细。","link":"/2020/07/03/pat-a-1003/"},{"title":"PAT-A 1010 Radix (25)","text":"&nbsp;&nbsp;进制转换问题，又被测试点教做人了。 Given a pair of positive integers, for example, 6 and 110, can this equation 6 = 110 be true? The answer is yes, if 6 is a decimal number and 110 is a binary number. Now for any pair of positive integers $N_1$ and $N_2$, your task is to find the radix of one number while that of the other is given. Problem:&nbsp;PAT-A 1010 Radix Input SpecificationEach input file contains one test case. Each case occupies a line which contains 4 positive integers: N1 N2 tag radix Here N1 and N2 each has no more than 10 digits. A digit is less than its radix and is chosen from the set { 0-9, a - z } where 0-9 represent the decimal numbers 0-9, and a - z represent the decimal numbers 10-35. The last number radix is the radix of N1 if tag is 1, or of N2 if tag is 2. Output SpecificationFor each test case, print in one line the radix of the other number so that the equation N1 = N2 is true. If the equation is impossible, print Impossible. If the solution is not unique, output the smallest possible radix. Sample Input 116 110 1 10 Sample Output 112 Sample Input 211 ab 1 2 Sample Output 21Impossible Analysis&emsp;&emsp;给两个数，已知其中一个数的基数，判断另一个数是否存在基数使两个数相等，求出该基数，不存在则输出 Impossible。从题意来看就是普通的进制转换，先求出已知基数的数的 10 进制，再求出另一个数在不同基数下转为 10 进制的值，比较两数大小，如果相等则当前基数为所求解。但是测试点很恐怖，参考了大佬的代码才全过。遇到以下坑： 题目未说明 基数取值范围。实际下限大于未知基数的数中的任何一个数字，上限为已知基数的数，并不是简单的数字 + 字母的 [2, 35]。 题目只说明了数最大有 10 位，所以 int 显然不够存了，而且如果基数比较大，那么 long long 也不够存。根据前辈们的踩坑经历，幸好测试用例中所有数据都在 long long 范围内，不然就太折腾了。 由于基数可能非常大，从小到大一个个遍历会有一个测试点过不去，因此搜索基数的时候采用 二分查找，使用的上限和下限也就是基数的取值范围。 二分查找的过程中会出现 long long 溢出 导致返回值为负数，查找时要增加判断。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;// 字符串转 10 进制ll str_to_dec(string str, ll radix) { ll res = 0; int len = str.size(); for (int i = 0; i &lt; len; i++) { int tmp = (isdigit(str[i]) ? str[i] - '0' : str[i] - 'a' + 10); res += tmp * pow(radix, len - i - 1); } return res;}// 获取基数ll get_radix(string str, ll num) { // num 为已知数的 10 进制 ll radix = 0; // 计算基数范围 char maxC = *max_element(str.begin(), str.end()); // 找到最大字符 ll lo = (isdigit(maxC) ? maxC - '0' : maxC - 'a' + 10) + 1; ll hi = max(lo, num); // 使用二分查找计算基数 while (lo &lt;= hi) { ll mid = (lo + hi) / 2; ll tmp = str_to_dec(str, mid); if (tmp &gt; num || tmp &lt; 0) { // 比已知数大或向上溢出 hi = mid - 1; } else if (tmp &lt; num) { // 比已知数小 lo = mid + 1; } else { radix = mid; break; } } return radix;}int main() { string N1, N2; int tag, radix; cin &gt;&gt; N1 &gt;&gt; N2 &gt;&gt; tag &gt;&gt; radix; ll num = (tag &amp; 1) ? str_to_dec(N1, radix) : str_to_dec(N2, radix); ll ans = (tag &amp; 1) ? get_radix(N2, num) : get_radix(N1, num); if (ans) { cout &lt;&lt; ans &lt;&lt; endl; } else { cout &lt;&lt; \"Impossible\" &lt;&lt; endl; }} Tsukkomi&emsp;&emsp;测试点太恶心（个人太菜），题目表述也不清（还是个人太菜）。折腾一下午，看着 20 个测试点的结果不断变换，始终有几个点过不去，心态爆炸。嫖完大佬的思路拐回来写，顿时觉得也没什么难度了，主要还是菜。","link":"/2020/07/04/pat-a-1010/"},{"title":"PAT-A 1021 Deepest Root (25)","text":"&nbsp;&nbsp;DFS 遍历无向图；计算树的深度；计算连通分量个数。 A graph which is connected and acyclic can be considered a tree. The height of the tree depends on the selected root. Now you are supposed to find the root that results in a highest tree. Such a root is called the deepest root. Problem:&nbsp;PAT-A 1021 Deepest Root Input SpecificationEach input file contains one test case. For each case, the first line contains a positive integer N (≤ $10^4$) which is the number of nodes, and hence the nodes are numbered from 1 to N. Then N−1 lines follow, each describes an edge by given the two adjacent nodes’ numbers. Output SpecificationFor each test case, print each of the deepest roots in a line. If such a root is not unique, print them in increasing order of their numbers. In case that the given graph is not a tree, print Error: K components where K is the number of connected components in the graph. Sample Input 11234551 21 31 42 5 Sample Output 1123345 Sample Input 21234551 31 42 53 4 Sample Output 21Error: 2 components Analysis&emsp;&emsp;判断无向图能否构成树结构，即是否为连通图、不成环。判断方法为计算无向图连通分量个数，如果大于 1 则为非连通图，输出错误提示。 &emsp;&emsp;使用两次 DFS 遍历无向图。第一次遍历选择任意结点作为树根，搜索到当前最深层的叶子结点，同时记录深度相同的叶子结点。第二次遍历，选择第一次遍历解集中的任意结点（最深层的叶子反过来也可以作为树根）作为根结点，获得第二次遍历的解集。两次遍历的解集取并集，使用 set 保存解集，去重并自动排序。 &nbsp;&nbsp;第一次遍历使用任意结点作为树根得出的最深层数不一定为最深。例如样例 1 从结点 1 开始遍历，获得最深层数为 3，即 1 -&gt; 2 -&gt; 5，而以 5 为树根进行遍历最深层数为 4，即 5 -&gt; 2 -&gt; 1 -&gt; 3(4)。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;using namespace std;const int mxN = 1e4 + 5;vector&lt;int&gt; G[mxN], tmp; // 无向图, 临时解集vector&lt;bool&gt; vis(mxN);int max_h = 0;void dfs(int idx, int h) { vis[idx] = true; if (h &gt; max_h) { max_h = h; tmp.clear(); tmp.push_back(idx); } else if (h == max_h) { tmp.push_back(idx); } // 搜索当前结点所有子结点 for (auto it = G[idx].begin(); it != G[idx].end(); it++) { if (vis[*it]) continue; dfs(*it, h + 1); }}int main() { ios::sync_with_stdio(false); cin.tie(0); int N; cin &gt;&gt; N; for (int i = 1; i &lt; N; i++) { int a, b; cin &gt;&gt; a &gt;&gt; b; G[a].push_back(b); G[b].push_back(a); } int K = 0; // 统计连通分量 for (int i = 1; i &lt;= N; i++) { if (!vis[i]) { dfs(i, 0); K++; } } if (K &gt; 1) { // 连通分量大于 1, 非连通图, 输出错误 cout &lt;&lt; \"Error: \" &lt;&lt; K &lt;&lt; \" components\" &lt;&lt; endl; return 0; } // 保存第一次深搜的解集 set&lt;int&gt; ans(tmp.begin(), tmp.end()); // 第二次深搜 fill(vis.begin(), vis.begin() + N + 1, false); dfs(tmp[0], 0); // 保存第二次深搜的解集 for (auto it = tmp.begin(); it != tmp.end(); it++) { ans.insert(*it); } for (auto it = ans.begin(); it != ans.end(); it++) { cout &lt;&lt; *it &lt;&lt; endl; }} Tsukkomi&emsp;&emsp;没什么好吐槽的，继续学习。","link":"/2020/07/05/pat-a-1021/"},{"title":"PAT-A 1029 Median (25)","text":"&nbsp;&nbsp;被测试点卡哭了，时间和内存都很抠。使用 Two Pointers 思想。 Given an increasing sequence S of N integers, the median is the number at the middle position. For example, the median of $S_1$ = { 11, 12, 13, 14 } is 12, and the median of $S_2$ = { 9, 10, 15, 16, 17 } is 15. The median of two sequences is defined to be the median of the nondecreasing sequence which contains all the elements of both sequences. For example, the median of $S_1$ and $S_2$ is 13. Given two increasing sequences of integers, you are asked to find their median. Problem:&nbsp;PAT-A 1029 Median Input SpecificationEach input file contains one test case. Each case occupies 2 lines, each gives the information of a sequence. For each sequence, the first positive integer N (≤ 2 × $10^5$) is the size of that sequence. Then N integers follow, separated by a space. It is guaranteed that all the integers are in the range of long int. Output SpecificationFor each test case you should output the median of the two given sequences in a line. Sample Input124 11 12 13 145 9 10 15 16 17 Sample Output113 Analysis&emsp;&emsp;这题乍一看以为是水题（其实就是水题），看数蛮大的就想着用哈希表统计数字出现次数，然后从小到大累加数字出现次数直至到达中位数。写完交上去的瞬间以为过了，眼睛扫到最下面发现最后一个测试点运行超时… &emsp;&emsp;网上搜一圈题解看到很多写法，但无非都是 Two Pointers 的思想。和归并排序差不多，两个指针 i 和 j 分别指向两个序列 $S_1$ 和 $S_2$ 的头部，不断选择最小的元素以生成第三个序列 $S_3$ 也就是合并后的序列。为了节约空间和时间，只读入 $S_1$，$S_2$ 只记录指针当前指向得数，边读入边移动指针，找到中位数即可结束读入。根据题目要求我们不需要真的生成第三个序列，只找到中位数即可，也就是排除 ($N_1$ + $N_2$ - 1) / 2 个数，然后从两个指针指向的数中选择较小的一个输出。 &emsp;&emsp;合并的序列 $S_3$ 中，可能出现 $S_1$ 所有数在中位数左边，或者 $S_2$ 所有数在中位数左边。因此在 $A_1$ 和 $A_2$ 的末尾添加无穷大，以结束该序列的搜索，具体见代码。 Code&emsp;&emsp;最开始的错误解法，哈希表统计数字。满心欢喜提交上去，结果有一个测试点显示超时，我枯了。 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;map&lt;int, int&gt; mp;int main() { ios::sync_with_stdio(false); cin.tie(0); int mid = 0; for (int i = 0; i &lt; 2; i++) { int N, num; cin &gt;&gt; N; mid += N; for (int j = 0; j &lt; N; j++) { cin &gt;&gt; num; mp[num]++; } } mid = ceil(mid / 2.0); int cnt = 0; for (auto it = mp.begin(); it != mp.end(); it++) { if (cnt + it-&gt;second &lt; mid) { cnt += it-&gt;second; } else { cout &lt;&lt; it-&gt;first &lt;&lt; endl; return 0; } }} &emsp;&emsp;下面是 AC 代码。嫖了大佬思路，用 Two Pointers 思想的解法。 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(0); int N1, N2; cin &gt;&gt; N1; vector&lt;int&gt; S1(N1 + 1); for (int i = 0; i &lt; N1; i++) { cin &gt;&gt; S1[i]; } S1[N1] = INT_MAX; cin &gt;&gt; N2; int mid = (N1 + N2 - 1) / 2, S2, i = 0, j = 0, cnt = 0; cin &gt;&gt; S2; while (cnt++ &lt; mid) { if (S1[i] &lt; S2) { i++; } else { if (++j &lt; N2) { cin &gt;&gt; S2; } else { S2 = INT_MAX; } } } cout &lt;&lt; (S1[i] &lt; S2 ? S1[i] : S2) &lt;&lt; endl;} Tsukkomi&emsp;&emsp;想着好不容易逮到一道水题正好让我爽一下，唰唰唰写完交上去结果被测试点卡得怀疑人生。如果考试时候出了这么道题，那我可能要打出 GG 了。","link":"/2020/07/06/pat-a-1029/"},{"title":"PAT-A 1056 Mice and Rice (25)","text":"&nbsp;&nbsp;简单模拟。使用队列模拟流程。 Mice and Rice is the name of a programming contest in which each programmer must write a piece of code to control the movements of a mouse in a given map. The goal of each mouse is to eat as much rice as possible in order to become a FatMouse. First the playing order is randomly decided for $N_P$ programmers. Then every $N​_G$ programmers are grouped in a match. The fattest mouse in a group wins and enters the next turn. All the losers in this turn are ranked the same. Every NG winners are then grouped in the next match until a final winner is determined. For the sake of simplicity, assume that the weight of each mouse is fixed once the programmer submits his/her code. Given the weights of all the mice and the initial playing order, you are supposed to output the ranks for the programmers. Problem:&nbsp;PAT-A 1056 Mice and Rice Input SpecificationEach input file contains one test case. For each case, the first line contains 2 positive integers: $N_P$ and $N_G$ (≤1000), the number of programmers and the maximum number of mice in a group, respectively. If there are less than $N_G$ mice at the end of the player’s list, then all the mice left will be put into the last group. The second line contains $N_P$ distinct non-negative numbers W​i(i = 0,⋯,$N_P$ − 1) where each Wi is the weight of the i-th mouse respectively. The third line gives the initial playing order which is a permutation of 0,⋯,$N_P$​ − 1 (assume that the programmers are numbered from 0 to $N_P$ − 1). All the numbers in a line are separated by a space. Output SpecificationFor each test case, print the final ranks in a line. The i-th number is the rank of the i-th programmer, and all the numbers must be separated by a space, with no extra space at the end of the line. Sample Input12311 325 18 0 46 37 3 19 22 57 56 106 0 8 7 10 5 9 1 4 2 3 Sample Output15 5 5 2 5 5 5 3 1 3 5 Analysis&emsp;&emsp;题目大意：有 $N_P$ 个程序猿，每只程序猿一只老鼠，参加老鼠比重量的比赛。每轮比赛划分多个组，每组 $N_G$ 位选手，如果最后剩余不足 $N_G$ 数量的选手也组成一组。每组中最重的老鼠晋级参加下一轮。要求计算出参赛选手的排名，其中同一轮的失败者名次并列。 &emsp;&emsp;按照题意模拟就 vans 了。数据读入第二行为每只老鼠的重量，第三行为老鼠的序号，因此需要先将序号与选手匹配（我用了 map ）。使用队列存放参赛选手，不断从队列取老鼠，每 $N_G$ 只判断一次获胜者，并添加至队列末端，对最后的不足 $N_G$ 选手的组也要判断。需要确定每一轮的 $N_P$，即总参赛鼠数，同时更新排名数据。详情见代码。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;struct mic { int idx, weit, ranc; // 序号, 重量, 排名};map&lt;int, mic&gt; mp;queue&lt;mic&gt; que;int main() { ios::sync_with_stdio(false); cin.tie(0); int NP, NG; cin &gt;&gt; NP &gt;&gt; NG; vector&lt;int&gt; W(NP); for (int i = 0; i &lt; NP; i++) { cin &gt;&gt; W[i]; } for (int i = 0; i &lt; NP; i++) { int idx; mic m; cin &gt;&gt; idx; m.idx = idx; m.weit = W[idx]; que.push(m); mp[idx] = m; } int cnt = 0, rk = ceil(NP * 1.0 / NG) + 1, mxW = -1, mxW_id; while (!que.empty()) { mic mm = que.front(); que.pop(); if (mm.weit &gt; mxW) { // 获取当前组最重数据 mxW = mm.weit; mxW_id = mm.idx; } mp[mm.idx].ranc = rk; // 更新排名 cnt++; if (cnt % NG == 0 || cnt == NP) { // 一组结束 que.push(mp[mxW_id]); // 添加获胜者至队尾 mxW = -1; if (cnt == NP) { // 本轮结束 NP = que.size(); // 更新选手数量 if (NP == 1) { // 只剩一老鼠，结束循环 mp[mxW_id].ranc = 1; break; } rk = ceil(NP * 1.0 / NG) + 1; // 计算下一组失败者名次 cnt = 0; } } } int flag = 0; for (auto &amp;i : mp) { if (flag) cout &lt;&lt; \" \"; cout &lt;&lt; i.second.ranc; flag++; }} Tsukkomi&emsp;&emsp;题目比较简单，但是读了好几遍才读懂，起初没明白输入第三行是干啥的，就很烦。第一遍代码写得逻辑很乱以为过不了，居然过了。改了改感觉还是不清晰，有缘再改吧。","link":"/2020/07/07/pat-a-1056/"},{"title":"PAT-A 1097 Deduplication on a Linked List (25)","text":"&nbsp;&nbsp;链表操作。出现段错误。 Given a singly linked list L with integer keys, you are supposed to remove the nodes with duplicated absolute values of the keys. That is, for each value K, only the first node of which the value or absolute value of its key equals K will be kept. At the mean time, all the removed nodes must be kept in a separate list. For example, given L being 21 → -15 → -15 → -7 → 15, you must output 21 → -15 → -7, and the removed list -15 → 15. Problem:&nbsp;PAT-A 1097 Deduplication on a Linked List Input SpecificationEach input file contains one test case. For each case, the first line contains the address of the first node, and a positive N (≤ $10^5$) which is the total number of nodes. The address of a node is a 5-digit nonnegative integer, and NULL is represented by −1. Then N lines follow, each describes a node in the format: Address Key Next where Address is the position of the node, Key is an integer of which absolute value is no more than $10^4$, and Next is the position of the next node. Output SpecificationFor each case, output the resulting linked list first, then the removed list. Each node occupies a line, and is printed in the same format as in the input. Sample Input12345600100 599999 -7 8765423854 -15 0000087654 15 -100000 -15 9999900100 21 23854 Sample Output1234500100 21 2385423854 -15 9999999999 -7 -100000 -15 8765487654 15 -1 Analysis&emsp;&emsp;题目大意：给一个链表，删除链表中绝对值相同的元素，并将删除的元素按照删除顺序组成新的链表。输出处理过的原链表和生成的删除链表。 &emsp;&emsp;简单的链表操作，注意输出为 5 位数字，左侧不足 5 位需要补零，另外要判断 -1 的输出。测试点中存在删除链表为空的数据，因此访问和输出删除链表时需要判断，否则会出现段错误。具体见代码 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;struct Node { int key, nxt;};map&lt;int, Node&gt; mp;map&lt;int, int&gt; vis;void print_ll(int cur) { while (cur != -1) { printf(\"%05d %d \", cur, mp[cur].key); if (mp[cur].nxt == -1) { printf(\"-1\\n\"); } else { printf(\"%05d\\n\", mp[cur].nxt); } cur = mp[cur].nxt; }}int main() { ios::sync_with_stdio(false); cin.tie(0); int head, N; cin &gt;&gt; head &gt;&gt; N; for (int i = 0; i &lt; N; i++) { Node nd; int addr; cin &gt;&gt; addr &gt;&gt; nd.key &gt;&gt; nd.nxt; mp[addr] = nd; } int res = head, rem_head = -1; Node *res_pre = &amp;mp[head], *rem_pre = NULL; while (res != -1) { int tmp = mp[res].nxt; if (vis[abs(mp[res].key)]) { if (rem_head == -1) { rem_head = res; } else { rem_pre-&gt;nxt = res; } rem_pre = &amp;mp[res]; } else { vis[abs(mp[res].key)]++; res_pre-&gt;nxt = res; res_pre = &amp;mp[res]; } res = tmp; } // 处理链表末尾 res_pre-&gt;nxt = -1; // 如果删除表为空则不访问, 否则出现段错误 if (rem_pre != NULL) rem_pre-&gt;nxt = -1; print_ll(head); print_ll(rem_head);} Tsukkomi&emsp;&emsp;没什么好吐槽的，早睡护肝儿。","link":"/2020/07/08/pat-a-1097/"},{"title":"PAT-A 1127 ZigZagging on a Tree (30)","text":"&nbsp;&nbsp;邻接矩阵实现有向图，使用 DFS 思想生成和处理数据 Suppose that all the keys in a binary tree are distinct positive integers. A unique binary tree can be determined by a given pair of postorder and inorder traversal sequences. And it is a simple standard routine to print the numbers in level-order. However, if you think the problem is too simple, then you are too naive. This time you are supposed to print the numbers in “zigzagging order” – that is, starting from the root, print the numbers level-by-level, alternating between left to right and right to left. For example, for the following tree you must output: 1 11 5 8 17 12 20 15. Problem:&nbsp;PAT-A 1127 ZigZagging on a Tree Input SpecificationEach input file contains one test case. For each case, the first line gives a positive integer N (≤30), the total number of nodes in the binary tree. The second line gives the inorder sequence and the third line gives the postorder sequence. All the numbers in a line are separated by a space. Output SpecificationFor each test case, print the zigzagging sequence of the tree in a line. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line. Sample Input123812 11 20 17 1 15 8 512 20 17 11 15 8 5 1 Sample Output11 11 5 8 17 12 20 15 Analysis&emsp;&emsp;通过中序和后序序列构造二叉树，然后按层输出。与普通层次遍历不同的是，偶数层（0 层开始）正序输出，奇数层倒序输出。使用 DFS 或 BFS 遍历整个树，记录各个结点的层号，将数据按层存放于数组。输出时逐层输出，根据层号判断使用正序或倒序输出。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;const int mxN = 75;int G[mxN][3], post[mxN], in[mxN];vector&lt;int&gt; res[mxN]; // 按层存放数据int build_tree(int pL, int pR, int iL, int iR) { if (pL &gt; pR) return -1; int k = iL; while (k &lt;= iR) { if (in[k] == post[pR]) break; k++; } int numleft = k - iL; G[post[pR]][0] = build_tree(pL, pL + numleft - 1, iL, k - 1); G[post[pR]][1] = build_tree(pL + numleft, pR - 1, k + 1, iR); return post[pR];}// 根据各结点的层号，按层存放数据int mxL = -1;void get_res(int r, int lyr) { mxL = max(mxL, lyr); // 获取层数 res[lyr].push_back(r); if (G[r][0] &gt; -1) get_res(G[r][0], lyr + 1); if (G[r][1] &gt; -1) get_res(G[r][1], lyr + 1);}int main() { ios::sync_with_stdio(false); cin.tie(0); int N; cin &gt;&gt; N; for (int i = 0; i &lt; N; i++) cin &gt;&gt; in[i]; for (int i = 0; i &lt; N; i++) cin &gt;&gt; post[i]; int root = build_tree(0, N - 1, 0, N - 1); get_res(root, 0); // 0, 2, 4 ... 倒序输出 // 1, 3, 5 ... 正序输出 int cnt = 0; for (int i = 0; i &lt;= mxL; i++) { int len = res[i].size(); if (i &amp; 1) { for (int j = 0; j &lt; len; j++) { cout &lt;&lt; \" \" &lt;&lt; res[i][j]; } } else { for (int j = len - 1; j &gt;= 0; j--) { if (cnt++) cout &lt;&lt; \" \"; cout &lt;&lt; res[i][j]; } } }} Tsukkomi&emsp;&emsp;巩固了一遍中序 + 后序序列生成二叉树，还行吧。一开始数组开了 35，交上去居然段错误？？题目标的 N &lt;= 30，但结点序号范围并不在 [1, N]。","link":"/2020/07/09/pat-a-1127/"},{"title":"PAT-A 1133 Splitting A Linked List (25)","text":"&nbsp;&nbsp;又是链表，又是段错误。 Given a singly linked list, you are supposed to rearrange its elements so that all the negative values appear before all of the non-negatives, and all the values in [0, K] appear before all those greater than K. The order of the elements inside each class must not be changed. For example, given the list being 18 → 7 → -4 → 0 → 5 → -6 → 10 → 11 → -2 and K being 10, you must output -4 → -6 → -2 → 7 → 0 → 5 → 10 → 18 → 11. Problem:&nbsp;PAT-A 1133 Splitting A Linked List Input SpecificationEach input file contains one test case. For each case, the first line contains the address of the first node, a positive N (≤ $10^5$) which is the total number of nodes, and a positive K (≤ $10^3$ ). The address of a node is a 5-digit nonnegative integer, and NULL is represented by −1. Then N lines follow, each describes a node in the format: Address Data Next where Address is the position of the node, Data is an integer in [−$10^5$, $10^5$], and Next is the position of the next node. It is guaranteed that the list is not empty. Output SpecificationFor each case, output in order (from beginning to the end of the list) the resulting linked list. Each node occupies a line, and is printed in the same format as in the input. Sample Input1234567891000100 9 1023333 10 2777700000 0 9999900100 18 1230968237 -6 2333333218 -4 0000048652 -2 -199999 5 6823727777 11 4865212309 7 33218 Sample Output12345678933218 -4 6823768237 -6 4865248652 -2 1230912309 7 0000000000 0 9999999999 5 2333323333 10 0010000100 18 2777727777 11 -1 Analysis&emsp;&emsp;题目大意：给一个链表，和一个正整数 K，要求链表中值为负数的元素在最左边，小于 K 的元素在 K 左边，大于 K 的元素在 K 右边。输出修改后的链表内容。 &emsp;&emsp;遍历链表，将小于 0 的元素、大于等于 0 且小于等于 K 的元素、大于 K 的元素分别保存于 3 个不同的数组中，使用 push_back() 确保顺序。不需要修改结点的 Next 属性，在输出 Next 时直接输出数组中下一结点的地址。 &nbsp;&nbsp;数字 K 不一定存在于链表中；根据思路划分的三个数组均可能为空，注意数组越界。 Code&emsp;&emsp;下面是第一回过的代码，比较莽，输出占了大部分。分了三个数组，整了一堆判断，起初在这段代码上被数组越界玩死了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;struct Node { int addr, data, nxt;};map&lt;int, Node&gt; mp;int main() { ios::sync_with_stdio(false); cin.tie(0); int hd, N, K; cin &gt;&gt; hd &gt;&gt; N &gt;&gt; K; for (int i = 0; i &lt; N; i++) { Node tmp; cin &gt;&gt; tmp.addr &gt;&gt; tmp.data &gt;&gt; tmp.nxt; mp[tmp.addr] = tmp; } vector&lt;Node&gt; neg, kl, kr; while (hd != -1) { if (mp[hd].data &lt; 0) { neg.push_back(mp[hd]); } else if (mp[hd].data &lt;= K) { kl.push_back(mp[hd]); } else { kr.push_back(mp[hd]); } hd = mp[hd].nxt; } int len = neg.size(); for (int i = 0; i &lt; len; i++) { printf(\"%05d %d \", neg[i].addr, neg[i].data); if (i == len - 1) { if (!kl.empty()) { printf(\"%05d\\n\", kl[0].addr); } else if (!kr.empty()){ printf(\"%05d\\n\", kr[0].addr); } else { printf(\"-1\\n\"); } } else { printf(\"%05d\\n\", neg[i + 1].addr); } } len = kl.size(); for (int i = 0; i &lt; len; i++) { printf(\"%05d %d \", kl[i].addr, kl[i].data); if (i == len - 1) { if (!kr.empty()) { printf(\"%05d\\n\", kr[0].addr); } else { printf(\"-1\\n\"); } } else { printf(\"%05d\\n\", kl[i + 1].addr); } } len = kr.size(); for (int i = 0; i &lt; len; i++) { printf(\"%05d %d \", kr[i].addr, kr[i].data); if (i == len - 1) { printf(\"-1\\n\"); } else { printf(\"%05d\\n\", kr[i + 1].addr); } }} &emsp;&emsp;下面是简化后的代码，可读性较强。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;struct Node { int addr, data, nxt;};map&lt;int, Node&gt; mp;int main() { ios::sync_with_stdio(false); cin.tie(0); int hd, N, K; cin &gt;&gt; hd &gt;&gt; N &gt;&gt; K; for (int i = 0; i &lt; N; i++) { Node tmp; cin &gt;&gt; tmp.addr &gt;&gt; tmp.data &gt;&gt; tmp.nxt; mp[tmp.addr] = tmp; } vector&lt;Node&gt; v[3]; while (hd != -1) { if (mp[hd].data &lt; 0) { v[0].push_back(mp[hd]); } else if (mp[hd].data &lt;= K) { v[1].push_back(mp[hd]); } else { v[2].push_back(mp[hd]); } hd = mp[hd].nxt; } int flag = 0; for (int i = 0; i &lt; 3; i++) { int len = v[i].size(); for (int j = 0; j &lt; len; j++) { if (!flag++) { printf(\"%05d %d \", v[i][j].addr, v[i][j].data); } else { printf(\"%05d\\n%05d %d \", v[i][j].addr, v[i][j].addr, v[i][j].data); } } } printf(\"-1\\n\");} Tsukkomi&emsp;&emsp;开始没仔细读题，以为 K 是链表中的元素，于是在第一遍的代码中默认第二个数组一定不为空了。交上去发现有两个测试点提示段错误，还有点怀疑人生。代码也写得太乱了，其实难度不大，但浪费了不少时间。","link":"/2020/07/10/pat-a-1133/"},{"title":"PAT-A 1030 Travel Plan (30)","text":"&nbsp;&nbsp;使用 Dijkstra 算法解决最短路径问题；使用 DFS 逆推整条路线。 A traveler’s map gives the distances between cities along the highways, together with the cost of each highway. Now you are supposed to write a program to help a traveler to decide the shortest path between his/her starting city and the destination. If such a shortest path is not unique, you are supposed to output the one with the minimum cost, which is guaranteed to be unique. Problem:&nbsp;PAT-A 1030 Travel Plan Input SpecificationEach input file contains one test case. Each case starts with a line containing 4 positive integers N, M, S, and D, where N (≤ 500) is the number of cities (and hence the cities are numbered from 0 to N − 1); M is the number of highways; S and D are the starting and the destination cities, respectively. Then M lines follow, each provides the information of a highway, in the format: City1 City2 Distance Cost where the numbers are all integers no more than 500, and are separated by a space. Output SpecificationFor each test case, print in one line the cities along the shortest path from the starting point to the destination, followed by the total distance and the total cost of the path. The numbers must be separated by a space and there must be no extra space at the end of output. Sample Input1234564 5 0 30 1 1 201 3 2 300 3 4 100 2 2 202 3 1 20 Sample Output10 2 3 3 40 Analysis&emsp;&emsp;给定起点 S 和终点 D，寻找 S 至 D 的最短路径。两座城市间的信息包括距离和耗费。最短路径不唯一，选择耗费最少的路径。输出路线上的城市序号、最短距离和最小耗费。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;const int mxN = 505;int N, M, S, D;int G[mxN][mxN], d[mxN], cost[mxN][mxN], c[mxN], pas[mxN];bool vis[mxN] = {false};void dijkstra(int s) { fill(d, d + N, INT_MAX); d[s] = 0; fill(c, c + N, INT_MAX); c[s] = 0; for (int i = 0; i &lt; N; i++) { int u = -1, MIN = INT_MAX; for (int j = 0; j &lt; N; j++) { if (!vis[j] &amp;&amp; d[j] &lt; MIN) { MIN = d[j]; u = j; } } if (u == -1) return; vis[u] = true; for (int v = 0; v &lt; N; v++) { if (!vis[v] &amp;&amp; G[u][v]) { if (d[u] + G[u][v] &lt; d[v]) { d[v] = d[u] + G[u][v]; c[v] = c[u] + cost[u][v]; pas[v] = u; // 记录前驱结点，即从 u → v } else if (d[u] + G[u][v] == d[v] &amp;&amp; c[u] + cost[u][v] &lt; c[v]) { c[v] = c[u] + cost[u][v]; pas[v] = u; // 记录前驱结点 } } } }}// 通过终点逆向推出路线，并正向输出void print_path(int v) { if (v == S) { cout &lt;&lt; v &lt;&lt; \" \"; return; } print_path(pas[v]); cout &lt;&lt; v &lt;&lt; \" \";}int main() { ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; N &gt;&gt; M &gt;&gt; S &gt;&gt; D; for (int i = 0; i &lt; M; i++) { int c1, c2, dd, cc; cin &gt;&gt; c1 &gt;&gt; c2 &gt;&gt; dd &gt;&gt; cc; G[c1][c2] = G[c2][c1] = dd; cost[c1][c2] = cost[c2][c1] = cc; } dijkstra(S); print_path(D); cout &lt;&lt; d[D] &lt;&lt; \" \" &lt;&lt; c[D];} Tsukkomi&emsp;&emsp;回顾 Dijkstra 算法，依然是瞄着模板打的。下次一定自己码出来……","link":"/2020/07/11/pat-a-1030/"},{"title":"PAT-A 1099 Build A Binary Search Tree (30)","text":"&nbsp;&nbsp;二分搜索树；中序遍历；层次遍历。 A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties: The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than or equal to the node’s key. Both the left and right subtrees must also be binary search trees. Given the structure of a binary tree and a sequence of distinct integer keys, there is only one way to fill these keys into the tree so that the resulting tree satisfies the definition of a BST. You are supposed to output the level order traversal sequence of that tree. The sample is illustrated by Figure 1 and 2. Problem:&nbsp;PAT-A 1099 Build A Binary Search Tree Input SpecificationEach input file contains one test case. For each case, the first line gives a positive integer N (≤100) which is the total number of nodes in the tree. The next N lines each contains the left and the right children of a node in the format left_index right_index, provided that the nodes are numbered from 0 to N−1, and 0 is always the root. If one child is missing, then −1 will represent the NULL child pointer. Finally N distinct integer keys are given in the last line. Output SpecificationFor each test case, print in one line the level order traversal sequence of that tree. All the numbers must be separated by a space, with no extra space at the end of the line. Sample Input123456789101191 62 3-1 -1-1 45 -1-1 -17 -1-1 8-1 -173 45 11 58 82 25 67 38 42 Sample Output158 25 82 11 38 67 45 73 42 Analysis&emsp;&emsp;题目大意：给一个二分搜索树的结构，和一个数字序列。将数字填入二分搜索树，即对于每个结点，左子树的结点小于父结点，右子树的结点大于等于父结点，左右子树也要满足二分搜索树的条件。最后按层次遍历输出序列。 &emsp;&emsp;由于中序遍历二分搜索树的序列是从小到大排列的，因此首先将序列从小到大排序，然后按照中序遍历将数字从小到大填入二分搜索树。不需要真的填，直接按层号保存数据，最后按层次顺序输出序列。 Code123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;int G[105][2], mxL = -1;vector&lt;int&gt; nod(105), LYR[105];void build_tree(int root, int lyr, int&amp; idx) { mxL = max(mxL, lyr); if (G[root][0] != -1) build_tree(G[root][0], lyr + 1, idx); LYR[lyr].push_back(nod[idx++]); if (G[root][1] != -1) build_tree(G[root][1], lyr + 1, idx);}int main() { ios::sync_with_stdio(false); cin.tie(0); int N, l, r; cin &gt;&gt; N; for (int i = 0; i &lt; N; i++) { cin &gt;&gt; l &gt;&gt; r; G[i][0] = l, G[i][1] = r; } for (int i = 0; i &lt; N; i++) { cin &gt;&gt; nod[i]; } sort(nod.begin(), nod.begin() + N); int idx = 0, flag = 0; build_tree(0, 0, idx); for (int i = 0; i &lt;= mxL; i++) { int len = LYR[i].size(); for (int j = 0; j &lt; len; j++) { if (flag++) cout &lt;&lt; \" \"; cout &lt;&lt; LYR[i][j]; } }} Tsukkomi&emsp;&emsp;希望考试的时候 30 分的题也出这种……","link":"/2020/07/13/pat-a-1099/"},{"title":"PAT-A 1151 LCA in a Binary Tree (30)","text":"&nbsp;&nbsp;通过先序和中序寻找两个结点的最近共同祖先。 The lowest common ancestor (LCA) of two nodes U and V in a tree is the deepest node that has both U and V as descendants. Given any two nodes in a binary tree, you are supposed to find their LCA. Problem:&nbsp;PAT-A 1151 LCA in a Binary Tree Input SpecificationEach input file contains one test case. For each case, the first line gives two positive integers: M (≤ 1,000), the number of pairs of nodes to be tested; and N (≤ 10,000), the number of keys in the binary tree, respectively. In each of the following two lines, N distinct integers are given as the inorder and preorder traversal sequences of the binary tree, respectively. It is guaranteed that the binary tree can be uniquely determined by the input sequences. Then M lines follow, each contains a pair of integer keys U and V. All the keys are in the range of int. Output SpecificationFor each given pair of U and V, print in a line LCA of U and V is A. if the LCA is found and A is the key. But if A is one of U and V, print X is an ancestor of Y. where X is A and Y is the other node. If U or V is not found in the binary tree, print in a line ERROR: U is not found. or ERROR: V is not found. or ERROR: U and V are not found.. Sample Input1234567896 87 2 3 4 6 5 1 85 3 7 2 6 4 8 12 68 17 912 -30 899 99 Sample Output123456LCA of 2 and 6 is 3.8 is an ancestor of 1.ERROR: 9 is not found.ERROR: 12 and -3 are not found.ERROR: 0 is not found.ERROR: 99 and 99 are not found. Analysis&emsp;&emsp;题目大意：提供二叉树的中序和先序遍历，然后 M 对结点，寻找每对结点 (U 和 V) 的最近共同祖先，按规定格式输出结果。 &emsp;&emsp;在先序中设置光标，选择结点作为根结点。然后在通过中序判断当前根结点与 U 和 V 的位置关系。注意需要保存各结点在中序中的下标，通过下标进行上述判断，详情见代码。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; in, pre;map&lt;int, int&gt; mp;int M, N, u, v, inU, inV;// inL 为中序的左边界, preCur 为先序中的游标，即当前选中的根结点void LCA(int inL, int preCur) { // 获取当前根结点在中序中的下标 int inRoot = mp[pre[preCur]]; if ((inU &lt; inRoot &amp;&amp; inV &gt; inRoot) || (inU &gt; inRoot &amp;&amp; inV &lt; inRoot)) { cout &lt;&lt; \"LCA of \" &lt;&lt; u &lt;&lt; \" and \" &lt;&lt; v &lt;&lt; \" is \" &lt;&lt; in[inRoot] &lt;&lt; \".\" &lt;&lt; endl; } else if (inU &lt; inRoot &amp;&amp; inV &lt; inRoot) { // U, V 在当前根结点的左子树 LCA(inL, preCur + 1); } else if (inU &gt; inRoot &amp;&amp; inV &gt; inRoot) { // U, V 在当前根结点的右子树 LCA(inRoot + 1, preCur + (inRoot - inL) + 1); } else if (inU == inRoot) { // U 为根结点 cout &lt;&lt; u &lt;&lt; \" is an ancestor of \" &lt;&lt; v &lt;&lt; \".\" &lt;&lt; endl; } else if (inV == inRoot) { // V 为根结点 cout &lt;&lt; v &lt;&lt; \" is an ancestor of \" &lt;&lt; u &lt;&lt; \".\" &lt;&lt; endl; }}int main() { ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; M &gt;&gt; N; in.resize(N + 1), pre.resize(N + 1); for (int i = 1; i &lt;= N; i++) { cin &gt;&gt; in[i]; mp[in[i]] = i; // 保存结点的中序下标 } for (int i = 1; i &lt;= N; i++) { cin &gt;&gt; pre[i]; } for (int i = 0; i &lt; M; i++) { cin &gt;&gt; u &gt;&gt; v; if (!mp[u] &amp;&amp; !mp[v]) { cout &lt;&lt; \"ERROR: \" &lt;&lt; u &lt;&lt; \" and \" &lt;&lt; v &lt;&lt; \" are not found.\" &lt;&lt; endl; } else if (!mp[u] || !mp[v]) { cout &lt;&lt; \"ERROR: \" &lt;&lt; (!mp[u] ? u : v) &lt;&lt; \" is not found.\" &lt;&lt; endl; } else { inU = mp[u], inV = mp[v]; // 获取 U, V 在中序中的下标 LCA(1, 1); } }} Tsukkomi&emsp;&emsp;没啥吐槽的，碎了……","link":"/2020/07/14/pat-a-1151/"},{"title":"PAT-A 1018 Public Bike Management (30)","text":"&nbsp;&nbsp;阅读理解。使用 Dijkstra 获取所有最短路径；使用 DFS 遍历获取最优解。 There is a public bike service in Hangzhou City which provides great convenience to the tourists from all over the world. One may rent a bike at any station and return it to any other stations in the city. The Public Bike Management Center (PBMC) keeps monitoring the real-time capacity of all the stations. A station is said to be in perfect condition if it is exactly half-full. If a station is full or empty, PBMC will collect or send bikes to adjust the condition of that station to perfect. And more, all the stations on the way will be adjusted as well. When a problem station is reported, PBMC will always choose the shortest path to reach that station. If there are more than one shortest path, the one that requires the least number of bikes sent from PBMC will be chosen. The above figure illustrates an example. The stations are represented by vertices and the roads correspond to the edges. The number on an edge is the time taken to reach one end station from another. The number written inside a vertex S is the current number of bikes stored at S. Given that the maximum capacity of each station is 10. To solve the problem at $S_3$, we have 2 different shortest paths: PBMC -&gt; $S_1$ -&gt; $S_3$. In this case, 4 bikes must be sent from PBMC, because we can collect 1 bike from $S_1$ and then take 5 bikes to $S_​3$, so that both stations will be in perfect conditions. PBMC -&gt; $S_2$ -&gt; $S_3$. This path requires the same time as path 1, but only 3 bikes sent from PBMC and hence is the one that will be chosen. Problem:&nbsp;PAT-A 1018 Public Bike Management Input SpecificationEach input file contains one test case. For each case, the first line contains 4 numbers: $C_{max}$ (≤100), always an even number, is the maximum capacity of each station; N (≤500), the total number of stations; $S_p$, the index of the problem station (the stations are numbered from 1 to N, and PBMC is represented by the vertex 0); and M, the number of roads. The second line contains N non-negative numbers $C_i$(i=1,⋯,N) where each $C_i$ is the current number of bikes at $S_i$ respectively. Then M lines follow, each contains 3 numbers: $S_i$, $S_j$, and $T_{ij}$ which describe the time $T_​{ij}$ taken to move betwen stations $S_i$ and $S_j$ . All the numbers in a line are separated by a space. Output SpecificationFor each test case, print your results in one line. First output the number of bikes that PBMC must send. Then after one space, output the path in the format: 0−&gt;$S_1$−&gt;⋯−&gt;$S_p$. Finally after another space, output the number of bikes that we must take back to PBMC after the condition of $S_p$ is adjusted to perfect. Note that if such a path is not unique, output the one that requires minimum number of bikes that we must take back to PBMC. The judge’s data guarantee that such a path is unique. Sample Input123456710 3 3 56 7 00 1 10 2 10 3 31 3 12 3 1 Sample Output13 0-&gt;2-&gt;3 0 Analysis&emsp;&emsp;题目大意：共享单车调度，要求每个车站的共享单车数量为总容量的一半。当一个车站需要调度时，从管理中心出发，选择最短路线到达该车站，如果最短路线存在多条，那么选择从管理中心派送最少车辆的路线，途经的每个车站都要顺便把它调整为半满。例如 $S_3$ 缺 5 辆，沿途可从 $S_2$ 取走 2 辆给 $S_3$，因此只需要从管理中心取 3 辆，两个车站均达到半满。输出需要派送的最少单车数量，按格式输出路线，最后输出带回管理中心的最少单车数量。 &emsp;&emsp;使用 Dijkstra 算法获取最短路径，记录路径中每个结点的前置结点。因为有距离相同的情况，使用二维数组保存前置结点，从而获得多条路径。使用 DFS 对所有最短路径进行遍历，比较每条路径的派送和带回单车的数量，获得最少派送数量和最少派送条件下的最少带回数量。 &nbsp;&nbsp;坑： 行驶路线是单向无往返的，也就是从管理中心出发，每到一个车站就要将该车站的单车数量调整为半满，不能利用返程调整。例如：总容量为 10，$S_1$为 2，$S_2$为 8，路线 PBMC-&gt;$S_1$-&gt;$S_2$，不能从$S_2$取 3 辆调度到 $S_1$，需要从管理中心派送 3 辆，并带回 3 辆。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;bits/stdc++.h&gt;using namespace std;const int mxN = 505;int C, N, S, M, G[mxN][mxN], w[mxN], d[mxN];vector&lt;int&gt; pre[mxN], path, tmp_path;bool vis[mxN];void dijkstra(int s) { fill(d, d + mxN, INT_MAX); d[s] = 0; for (int i = 0; i &lt;= N; i++) { int u = -1, mnD = INT_MAX; for (int j = 0; j &lt;= N; j++) { if (!vis[j] &amp;&amp; d[j] &lt; mnD) { mnD = d[j]; u = j; } } if (u == -1) return; vis[u] = true; for (int v = 0; v &lt;= N; v++) { if (!vis[v] &amp;&amp; G[u][v] != INT_MAX) { if (d[u] + G[u][v] &lt; d[v]) { d[v] = d[u] + G[u][v]; pre[v].clear(); pre[v].push_back(u); } else if (d[u] + G[u][v] == d[v]) { pre[v].push_back(u); } } } }}int min_bk = INT_MAX, min_sd = INT_MAX;void dfs(int v) { tmp_path.push_back(v); if (v == 0) { int len = tmp_path.size(), bk = 0, sd = 0; for (int i = len - 2; i &gt;= 0; i--) { // 去掉出发点 int num = w[tmp_path[i]] - C / 2; // 当前车站的数量情况 if (num &lt; 0) { // 缺车 if (-num &gt; bk) { sd += -num - bk; bk = 0; } else { bk += num; } } else if (num &gt; 0) { // 多车 bk += num; } } if (sd &lt; min_sd) { min_sd = sd; min_bk = bk; path = tmp_path; } else if (sd == min_sd &amp;&amp; bk &lt; min_bk) { min_bk = bk; path = tmp_path; } } int len = pre[v].size(); for (int i = 0; i &lt; len; i++) { dfs(pre[v][i]); } tmp_path.pop_back();}int main() { ios::sync_with_stdio(false); cin.tie(0); fill (G[0], G[0] + mxN * mxN, INT_MAX); cin &gt;&gt; C &gt;&gt; N &gt;&gt; S &gt;&gt; M; for (int i = 1; i &lt;= N; i++) { cin &gt;&gt; w[i]; // 单车数量 } for (int i = 0; i &lt; M; i++) { int a, b, t; cin &gt;&gt; a &gt;&gt; b &gt;&gt; t; G[a][b] = G[b][a] = t; } dijkstra(0); dfs(S); cout &lt;&lt; min_sd &lt;&lt; \" \"; int len = path.size(); for (int i = len - 1; i &gt;= 0; i--) { if (i &lt; len - 1) cout &lt;&lt; \"-&gt;\"; cout &lt;&lt; path[i]; } cout &lt;&lt; \" \" &lt;&lt; min_bk &lt;&lt; endl;} Tsukkomi&emsp;&emsp;瞎脑补了一堆骚操作，怼了一个多小时，测试点就只过一半。网上搜大佬题解才知道自己加戏了，路程是单向的…… 另外题目说明了要选择从管理中心派送单车数量最少的路线，如果存在多条路线派送数量相同，那么选带回单车数量最少的。","link":"/2020/07/15/pat-a-1018/"},{"title":"PAT-A 1047 Student List for Course (25)","text":"&nbsp;&nbsp;对不起，我再也不敢用 cout 了。 Zhejiang University has 40,000 students and provides 2,500 courses. Now given the registered course list of each student, you are supposed to output the student name lists of all the courses. Problem:&nbsp;PAT-A 1047 Student List for Course Input SpecificationEach input file contains one test case. For each case, the first line contains 2 numbers: $N(≤40,000)$, the total number of students, and $K(≤2,500)$, the total number of courses. Then $N$ lines follow, each contains a student’s name (3 capital English letters plus a one-digit number), a positive number $C(≤20)$ which is the number of courses that this student has registered, and then followed by $C$ course numbers. For the sake of simplicity, the courses are numbered from 1 to $K$ . Output SpecificationFor each test case, print the student name lists of all the courses in increasing order of the course numbers. For each course, first print in one line the course number and the number of registered students, separated by a space. Then output the students’ names in alphabetical order. Each name occupies a line. Sample Input123456789101110 5ZOE1 2 4 5ANN0 3 5 2 1BOB5 5 3 4 2 1 5JOE4 1 2JAY9 4 1 2 5 4FRA8 3 4 2 5DON2 2 4 5AMY7 1 5KAT3 3 5 4 2LOR6 4 2 4 1 5 Sample Output1234567891011121314151617181920212223242526272829303132331 4ANN0BOB5JAY9LOR62 7ANN0BOB5FRA8JAY9JOE4KAT3LOR63 1BOB54 7BOB5DON2FRA8JAY9KAT3LOR6ZOE15 9AMY7ANN0BOB5DON2FRA8JAY9KAT3LOR6ZOE1 Analysis&emsp;&emsp;水题，排序完输出即可。 &emsp;&emsp;cout 会超时，关闭同步也没用，老老实实用 scanf 和 printf。 Code1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;string&gt; G[2505];int main() { ios::sync_with_stdio(false); cin.tie(0); int N, K; cin &gt;&gt; N &gt;&gt; K; for (int i = 0; i &lt; N; i++) { string stu; int C; cin &gt;&gt; stu &gt;&gt; C; while (C--) { int crs; cin &gt;&gt; crs; G[crs].push_back(stu); } } for (int i = 1; i &lt;= K; i++) { int len = G[i].size(); printf(\"%d %d\\n\", i, len); sort(G[i].begin(), G[i].end()); for (int j = 0; j &lt; len; j++) { printf(\"%s\\n\", G[i][j].c_str()); } }} Tsukkomi&emsp;&emsp;在刷 PAT 甲级之前只被 cin 绊过，以为关闭同步就万事大吉了。事实证明 cin/cout 确实比 scanf/printf 要慢的，输入输出数据量大的时候老老实实用后者。","link":"/2020/07/16/pat-a-1047/"},{"title":"PAT-A 1057 Stack (30)","text":"&nbsp;&nbsp;使用分桶法，平方分割解决超时问题。 Stack is one of the most fundamental data structures, which is based on the principle of Last In First Out (LIFO). The basic operations include Push (inserting an element onto the top position) and Pop (deleting the top element). Now you are supposed to implement a stack with an extra operation: PeekMedian – return the median value of all the elements in the stack. With $N$ elements, the median value is defined to be the $(N/2)$-th smallest element if $N$ is even, or $((N+1)/2)$-th if $N$ is odd. Problem:&nbsp;PAT-A 1057 Stack Input SpecificationEach input file contains one test case. For each case, the first line contains a positive integer $N(≤10^5)$. Then $N$ lines follow, each contains a command in one of the following 3 formats: Push keyPopPeekMedian where key is a positive integer no more than $10^5$. Output SpecificationFor each Push command, insert key into the stack and output nothing. For each Pop or PeekMedian command, print in a line the corresponding returned value. If the command is invalid, print Invalid instead. Sample Input12345678910111213141516171817PopPeekMedianPush 3PeekMedianPush 2PeekMedianPush 1PeekMedianPopPopPush 5Push 4PeekMedianPopPopPopPop Sample Output123456789101112InvalidInvalid322124453Invalid Analysis&emsp;&emsp;题目大意：在栈操作的基础上，添加获取中位数的操作。 &emsp;&emsp;起初用哈希表统计每个数字出现的次数，利用 map 的自动排序特性，从小到大累加至中位数。然鹅超时，然后在网上学了分桶法，即把大桶的数据分到一个个小桶中进行管理；平方分割，即把 $N$ 个元素分割为 $\\sqrt{N}$ 部分。也就是每个桶的大小为 $\\sqrt{N}$ ，在查找数据时先找到数据所在的桶，然后再在该桶内找具体数据。详情见代码。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;const int mxN = 1e5 + 10;const int sqrN = 317;stack&lt;int&gt; stk;vector&lt;int&gt; blk(sqrN), tb(mxN);int main() { ios::sync_with_stdio(false); cin.tie(0); int N, p = 0; cin &gt;&gt; N; for (int i = 0; i &lt; N; i++) { string cmd; cin &gt;&gt; cmd; if (cmd[1] == 'u') { int num; cin &gt;&gt; num; stk.push(num); blk[num / sqrN]++; tb[num]++; } else { if (stk.empty()) { printf(\"Invalid\\n\"); } else { if (cmd[1] == 'e') { int mid, cnt = 0, idx = 0, len = stk.size(); if (len &amp; 1) mid = (len + 1) / 2; else mid = len / 2; while (cnt + blk[idx] &lt; mid) { cnt += blk[idx++]; } idx *= sqrN; while (cnt + tb[idx] &lt; mid) { cnt += tb[idx++]; } printf(\"%d\\n\", idx); } else { int t = stk.top(); stk.pop(); printf(\"%d\\n\", t); blk[t / sqrN]--; tb[t]--; } } } }} Tsukkomi&emsp;&emsp;这道题还有好多解法，有空补上。","link":"/2020/07/16/pat-a-1057/"},{"title":"PAT-A 1074 Reversing Linked List (25)","text":"&nbsp;&nbsp;翻转链表，注意有不在链表上的结点。 Given a constant $K$ and a singly linked list L, you are supposed to reverse the links of every $K$ elements on $L$. For example, given L being 1→2→3→4→5→6, if $K=3$, then you must output 3→2→1→6→5→4; if $K=4$, you must output 4→3→2→1→5→6. Problem:&nbsp;PAT-A 1074 Reversing Linked List Input SpecificationEach input file contains one test case. For each case, the first line contains the address of the first node, a positive $N(≤10^5)$ which is the total number of nodes, and a positive $K(≤N)$ which is the length of the sublist to be reversed. The address of a node is a 5-digit nonnegative integer, and NULL is represented by -1. Then $N$ lines follow, each describes a node in the format: Address Data Next where Address is the position of the node, Data is an integer, and Next is the position of the next node. Output SpecificationFor each case, output the resulting ordered linked list. Each node occupies a line, and is printed in the same format as in the input. Sample Input123456700100 6 400000 4 9999900100 1 1230968237 6 -133218 3 0000099999 5 6823712309 2 33218 Sample Output12345600000 4 3321833218 3 1230912309 2 0010000100 1 9999999999 5 6823768237 6 -1 Analysis&emsp;&emsp;题目大意：给一个链表，每 $K$ 个结点翻转一次，即倒着输出这 $K$ 个结点。不足 $K$ 个结点的部分不反转。 &emsp;&emsp;注意输入的结点可能不全在链表上，所以按照地址遍历一遍把结点放入 vector。然后遍历 vector，每次取 $K$ 个结点并反向输出。不需要修改 next，直接输出下一结点的地址，详情见代码。 Code123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;struct Node { int val; string addr, next;};unordered_map&lt;string, Node&gt; mp;int main() { string fst; fst.resize(10); int N, K; scanf(\"%s %d %d\", &amp;fst[0], &amp;N, &amp;K); Node t; t.addr.resize(10); t.next.resize(10); while (N--) { scanf(\"%s %d %s\", &amp;t.addr[0], &amp;t.val, &amp;t.next[0]); mp[t.addr] = t; } vector&lt;Node&gt; v; while (fst[0] != '-') { v.push_back(mp[fst]); fst = mp[fst].next; } int len = v.size(), flag = 0; for (int i = 0; (i + 1) * K &lt;= len; i++) { for (int j = (i + 1) * K - 1; j &gt;= i * K; j--) { if (flag) printf(\"%s\\n%s %d \", v[j].addr.c_str(), v[j].addr.c_str(), v[j].val); else printf(\"%s %d \", v[j].addr.c_str(), v[j].val); flag++; } } for (int i = len - len % K; i &lt; len; i++) { if (flag) printf(\"%s\\n%s %d \", v[i].addr.c_str(), v[i].addr.c_str(), v[i].val); else printf(\"%s %d \", v[i].addr.c_str(), v[i].val); flag++; } printf(\"-1\\n\");} Tsukkomi&emsp;&emsp;19 年年底考乙级的前一天临时抱佛 jio 刷到这题的兄弟，当时被卡到怀疑人生然后放弃，生怕第二天考试遇到类似的题。结果考试时的最后一题真的就是那道改的，当时一个劲调整心态，希望前一天没过的题今天能搞出来。记得是只有一个测试点过不去，当时还不怎么熟悉 STL，单纯地写成了链表并且修改每个结点的 next。写到最后十几分钟抱着试一试的心态改成按地址输出，交上去顺利拿到满分！当时又开心又惭愧，开心是乙级划水顺利拿到满分，松了口气；惭愧是觉得自己思维还太局限，能力还差得远。总之，继续加油！","link":"/2020/07/17/pat-a-1074/"},{"title":"PAT-A 1091 Acute Stroke (30)","text":"&nbsp;&nbsp;BFS 广度优先搜索。 One important factor to identify acute stroke (急性脑卒中) is the volume of the stroke core. Given the results of image analysis in which the core regions are identified in each MRI slice, your job is to calculate the volume of the stroke core. Problem:&nbsp;PAT-A 1091 Acute Stroke Input SpecificationEach input file contains one test case. For each case, the first line contains 4 positive integers: $M$, $N$, $L$ and $T$, where $M$ and $N$ are the sizes of each slice (i.e. pixels of a slice are in an $M×N$ matrix, and the maximum resolution is 1286 by 128); $L(≤60)$ is the number of slices of a brain; and $T$ is the integer threshold (i.e. if the volume of a connected core is less than $T$, then that core must not be counted). Then $L$ slices are given. Each slice is represented by an $M×N$ matrix of 0’s and 1’s, where 1 represents a pixel of stroke, and 0 means normal. Since the thickness of a slice is a constant, we only have to count the number of 1’s to obtain the volume. However, there might be several separated core regions in a brain, and only those with their volumes no less than $T$ are counted. Two pixels are connected and hence belong to the same region if they share a common side, as shown by Figure 1 where all the 6 red pixels are connected to the blue one. Output SpecificationFor each case, output in a line the total volume of the stroke core. Sample Input123456789101112131415163 4 5 21 1 1 11 1 1 11 1 1 10 0 1 10 0 1 10 0 1 11 0 1 10 1 0 00 0 0 01 0 1 10 0 0 00 0 0 00 0 0 10 0 0 11 0 0 0 Sample Output126 Analysis&emsp;&emsp;题目大意：按照上面图示的连接方式，在三维数组里搜索 1 的数量。其中 1 数量大于等于 $T$ 的区域被认为是 stroke core，否则无视。求所有符合要求的区域中一共多少个 1 即体积。 &emsp;&emsp;基础 BFS 题，注意搜索的是上面图示的邻近 6 个结点，做好边界判断。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;int M, N, L, T, G[65][1300][130];int dh[] = {1, 0, 0, 0, 0, -1}, dx[] = {0, -1, 0, 1, 0, 0}, dy[] = {0, 0, 1, 0, -1, 0};struct Node { int x, y, h;};int bfs(int h, int x, int y) { queue&lt;Node&gt; que; que.push(Node{x, y, h}); int cnt = 0; while (!que.empty()) { Node node = que.front(); que.pop(); cnt++; for (int i = 0; i &lt; 6; i++) { int nh = node.h + dh[i]; int nx = node.x + dx[i]; int ny = node.y + dy[i]; if (nh &lt; 0 || nh &gt;= L || nx &lt; 0 || nx &gt;= M || ny &lt; 0 || ny &gt;= N || G[nh][nx][ny] == 0) continue; G[nh][nx][ny] = 0; que.push(Node{nx, ny, nh}); } } return cnt;}int main() { scanf(\"%d %d %d %d\", &amp;M, &amp;N, &amp;L, &amp;T); for (int i = 0; i &lt; L; i++) { for (int j = 0; j &lt; M; j++) { for (int k = 0; k &lt; N; k++) { scanf(\"%d\", &amp;G[i][j][k]); } } } int ans = 0; for (int i = 0; i &lt; L; i++) { for (int j = 0; j &lt; M; j++) { for (int k = 0; k &lt; N; k++) { if (G[i][j][k] == 1) { G[i][j][k] = 0; int tmp = bfs(i, j, k); if (tmp &gt;= T) ans += tmp; } } } } cout &lt;&lt; ans;} Tsukkomi&emsp;&emsp;30 分白送，嘻嘻。","link":"/2020/07/18/pat-a-1091/"},{"title":"PAT-A 1016 Phone Bills (25)","text":"&nbsp;&nbsp;结构体排序。 A long-distance telephone company charges its customers by the following rules: Making a long-distance call costs a certain amount per minute, depending on the time of day when the call is made. When a customer starts connecting a long-distance call, the time will be recorded, and so will be the time when the customer hangs up the phone. Every calendar month, a bill is sent to the customer for each minute called (at a rate determined by the time of day). Your job is to prepare the bills for each month, given a set of phone call records. Problem:&nbsp;PAT-A 1016 Phone Bills Input SpecificationEach input file contains one test case. Each case has two parts: the rate structure, and the phone call records. The rate structure consists of a line with 24 non-negative integers denoting the toll (cents/minute) from 00:00 - 01:00, the toll from 01:00 - 02:00, and so on for each hour in the day. The next line contains a positive number $N(≤1000)$, followed by $N$ lines of records. Each phone call record consists of the name of the customer (string of up to 20 characters without space), the time and date (MM:dd:HH:mm), and the word on-line or off-line. For each test case, all dates will be within a single month. Each on-line record is paired with the chronologically next record for the same customer provided it is an off-line record. Any on-line records that are not paired with an off-line record are ignored, as are off-line records not paired with an on-line record. It is guaranteed that at least one call is well paired in the input. You may assume that no two records for the same customer have the same time. Times are recorded using a 24-hour clock. Output SpecificationFor each test case, you must print a phone bill for each customer. Bills must be printed in alphabetical order of customers’ names. For each customer, first print in a line the name of the customer and the month of the bill in the format shown by the sample. Then for each time period of a call, print in one line the beginning and ending time and date (dd:HH:mm), the lasting time (in minute) and the charge of the call. The calls must be listed in chronological order. Finally, print the total charge for the month in the format shown by the sample. Sample Input12345678910111210 10 10 10 10 10 20 20 20 15 15 15 15 15 15 15 20 30 20 15 15 10 10 1010CYLL 01:01:06:01 on-lineCYLL 01:28:16:05 off-lineCYJJ 01:01:07:00 off-lineCYLL 01:01:08:03 off-lineCYJJ 01:01:05:59 on-lineaaa 01:01:01:03 on-lineaaa 01:02:00:01 on-lineCYLL 01:28:15:41 on-lineaaa 01:05:02:24 on-lineaaa 01:04:23:59 off-line Sample Output12345678910CYJJ 0101:05:59 01:07:00 61 $12.10Total amount: $12.10CYLL 0101:06:01 01:08:03 122 $24.4028:15:41 28:16:05 24 $3.85Total amount: $28.25aaa 0102:00:01 04:23:59 4318 $638.80Total amount: $638.80 Analysis&emsp;&emsp;题目大意：计算用户的通话账单，首先给出 24 小时中每小时的收费标准。然后给出用户的接通和挂断的时间记录，接通和挂断必须按时间顺序相互匹配，否则无视。最后按格式输出用户的通话记录、通话时长、费用等信息。 &emsp;&emsp;创建结构体保存每条通话记录的用户名、时间及状态，将所有通话记录按用户名从小到大排序，用户名相同的按记录时间排序。然后遍历排序后的通话记录 $V$，如果 $V_i$ 与 $V_{i+1}$ 用户名相同，且一个接听一个挂断，则匹配成功。先输出用户名和月份，如果已输出则跳过，之后计算这一对记录的通话时长和费用并按要求输出记录。当一个用户的账单信息输出结束，输出该用户的总费用。具体见代码。 坑及注意事项 所有数据均在同一月，不需要对月份处理。 通话记录存在跨日的，需要特别判断。 string 必须用 cin/cout，否则就用 char[]。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;struct Rec { char name[25]; int dd, HH, mm, time; bool on; bool operator &lt; (const Rec &amp;x) const { return (strcmp(name, x.name) == 0 ? time &lt; x.time : strcmp(name, x.name) &lt; 0); }};int N, c[25];vector&lt;Rec&gt; v(1005);double GetCharge(Rec A, Rec B) { double res = 0; while (A.dd != B.dd || A.HH != B.HH || A.mm != B.mm) { if (A.dd == B.dd &amp;&amp; A.HH == B.HH) { res += c[A.HH] * (B.mm - A.mm); A.mm = B.mm; } else { res += c[A.HH] * (60 - A.mm); A.mm = 0; if (A.HH == 23) { A.HH = 0; A.dd++; } else { A.HH++; } } } return res / 100;}int main() { for (int i = 0; i &lt; 24; i++) { scanf(\"%d\", &amp;c[i]); } scanf(\"%d\", &amp;N); int MM; char sign[10]; for (int i = 0; i &lt; N; i++) { scanf(\"%s %d:%d:%d:%d %s\", v[i].name, &amp;MM, &amp;v[i].dd, &amp;v[i].HH, &amp;v[i].mm, sign); v[i].time = (v[i].dd * 24 + v[i].HH) * 60 + v[i].mm; if (sign[1] == 'n') v[i].on = true; else v[i].on = false; } sort(v.begin(), v.begin() + N); int flag = 0; double total_amt = 0; for (int i = 0; i &lt; N - 1; i++) { if (strcmp(v[i].name, v[i + 1].name) == 0 &amp;&amp; v[i].on &amp;&amp; !v[i + 1].on) { if (!flag) { printf(\"%s %02d\\n\", v[i].name, MM); flag = 1; } double chag = GetCharge(v[i], v[i + 1]); printf(\"%02d:%02d:%02d %02d:%02d:%02d \", v[i].dd, v[i].HH, v[i].mm, v[i + 1].dd, v[i + 1].HH, v[i + 1].mm); printf(\"%d $%.2f\\n\", v[i + 1].time - v[i].time, chag); total_amt += chag; } else if (strcmp(v[i].name, v[i + 1].name)){ if (flag) { printf(\"Total amount: $%.2f\\n\", total_amt); } flag = total_amt = 0; } } if (flag) { printf(\"Total amount: $%.2f\\n\", total_amt); }} Tsukkomi&emsp;&emsp;起初我的 string 类型是先 resize 然后按地址用 scanf 输入的，输出的时候用 printf 配合 c_str()，然鹅样例过了，交上去却全是错的。我以为是有逻辑错误，就在网上查，看到有人说费用为 0 的不能输出，于是我就先处理信息再输出，结果还是全错。然后看到有人说 string 不能用，我就把涉及 string 的输入/输出改成了 cin/cout，结果交上去真的 AC 了？？？最后证明测试点中并没有费用为 0 不输出的坑，string 的坑是有的，虽然暂时不清楚为什么。 &emsp;&emsp;但是 u1s1，作为一道 25 分的题，确实有点恶心了。","link":"/2020/07/19/pat-a-1016/"},{"title":"PAT-A 1082 Read Number in Chinese (25)","text":"&nbsp;&nbsp;简单模拟，输出格式有坑。 Given an integer with no more than 9 digits, you are supposed to read it in the traditional Chinese way. Output Fu first if it is negative. For example, -123456789 is read as Fu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu. Note: zero (ling) must be handled correctly according to the Chinese tradition. For example, 100800 is yi Shi Wan ling ba Bai. Problem:&nbsp;PAT-A 1082 Read Number in Chinese Input SpecificationEach input file contains one test case, which gives an integer with no more than 9 digits. Output SpecificationFor each test case, print in a line the Chinese way of reading the number. The characters are separated by a space and there must be no extra space at the end of the line. Sample Input 11-123456789 Sample Output 11Fu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu Sample Input 21100800 Sample Output 21yi Shi Wan ling ba Bai Analysis&emsp;&emsp;给一个最多九位的整数，用汉语拼音表示该数字，简单模拟。需要注意 0 的输出，当遇到 0 的时候做标记，直至遇到非 0 数时再输出 ling。测试点好像有一个输入数据是 0，所以对 0 的位置也要判断。另外测试点并不完全严谨，比如 100,000,000 不用严格输出 yi Yi，输出 yi Yi Wan 并不影响。在输出至第 4 位或第 8 位的时候无论当前位是不是 0，都要输出 Wan 或 Yi。 &emsp;&emsp;遇到的坑： 个位的 “” 并不是空的，会导致格式错误。 Code12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;string num[] = {\"ling\", \"yi\", \"er\", \"san\", \"si\", \"wu\", \"liu\", \"qi\", \"ba\", \"jiu\"};string jw[] = {\"\", \"Shi\", \"Bai\", \"Qian\", \"Wan\", \"Shi\", \"Bai\", \"Qian\", \"Yi\"};int main() { string str; cin &gt;&gt; str; int flag = 0; if (str[0] == '-') { printf(\"Fu\"); str = str.substr(1); flag++; } int len = str.size(), zero = 0; for (int i = 0; i &lt; len; i++) { if (str[i] == '0' &amp;&amp; i) { zero = 1; } else { if (zero) printf(\" ling\"); if (flag++) printf(\" \"); printf(\"%s\", num[str[i] - '0'].c_str()); zero = 0; } int tmp = len - i - 1; if (tmp &amp;&amp; (!zero || tmp == 4 || tmp == 8)) { // tmp为 0 时输出 \"\" 会格式错误 printf(\" %s\", jw[tmp % 9].c_str()); } }} Tsukkomi&emsp;&emsp;格式错误给我整懵了，改了半天寻思空格也没搁错啊…… 万万想不到被 “” 卡了。这题以前好像在蓝桥杯的 OJ 上写过，测试也是不严谨，不过这次确实是写得最简洁的一次了。","link":"/2020/07/20/pat-a-1082/"}],"tags":[{"name":"PicGo","slug":"PicGo","link":"/tags/PicGo/"},{"name":"jsDelivr","slug":"jsDelivr","link":"/tags/jsDelivr/"},{"name":"Travis CI","slug":"Travis-CI","link":"/tags/Travis-CI/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"MongoDB","slug":"MongoDB","link":"/tags/MongoDB/"},{"name":"Mac OS","slug":"Mac-OS","link":"/tags/Mac-OS/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"BnB","slug":"BnB","link":"/tags/BnB/"},{"name":"Back Tracking","slug":"Back-Tracking","link":"/tags/Back-Tracking/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"Clion","slug":"Clion","link":"/tags/Clion/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"Lanqiao","slug":"Lanqiao","link":"/tags/Lanqiao/"},{"name":"PAT","slug":"PAT","link":"/tags/PAT/"},{"name":"Dijkstra","slug":"Dijkstra","link":"/tags/Dijkstra/"},{"name":"Graph","slug":"Graph","link":"/tags/Graph/"},{"name":"Two Pointers","slug":"Two-Pointers","link":"/tags/Two-Pointers/"},{"name":"Linked List","slug":"Linked-List","link":"/tags/Linked-List/"},{"name":"BFS","slug":"BFS","link":"/tags/BFS/"}],"categories":[{"name":"Tech","slug":"Tech","link":"/categories/Tech/"},{"name":"Note","slug":"Note","link":"/categories/Note/"},{"name":"Blog","slug":"Tech/Blog","link":"/categories/Tech/Blog/"},{"name":"Diary","slug":"Diary","link":"/categories/Diary/"},{"name":"Design Pattern","slug":"Note/Design-Pattern","link":"/categories/Note/Design-Pattern/"},{"name":"Problem","slug":"Note/Problem","link":"/categories/Note/Problem/"},{"name":"Cpp","slug":"Note/Cpp","link":"/categories/Note/Cpp/"}]}