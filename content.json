{"pages":[],"posts":[{"title":"First diary, Hello world!","text":"&emsp;&emsp;很早就想搞个博客记录学习和生活，留给未来回首往日。Emmm…之所以拖到今天才开始着手，一方面是因为疫情一直宅家想充实，一方面是面临考研，发现自己两年半来居然一点学习笔记也没留下。想想CXK练习时长两年半都出道了，自己考研前的寒假还爆肝了四五周游戏（u1s1，DQB2是真的香），爆肝之后的贤者模式告诉我，不能继续在游戏中堕落下去（该换个方式堕落了)，这也是为什么我会在这里用小学作文的水平码字。。。 &emsp;&emsp;产生这个想法是在大一时期，当时在老师的倡导下在学校OJ刷题，经常刷到凌晨（虽然水平没提升的多少，但头顶确实越来越冷了），题目怼不出来就复制题号在网上搜，也由此见识了很多大佬的CSDN、博客园博客，惊叹于大佬的解题能力和刷题量，也包括很多大佬的学习笔记、随笔 blahblah，当时就想着什么时候咱也得整一个！ &emsp;&emsp;然鹅只恨自己太懒，大一下学期题几乎不刷题了，很少再去搜题解（了解到学院不参加ACM，觉得刷题失去意义）。大二虽然学院突然开始参加比赛了，但糟糕的时间安排和被各种破事占用时间，刷题都没得刷，更别提写博客了，于是博客计划无限期搁置。。。 &emsp;&emsp;2020的寒假意外得长，寒假前我还计划像以往假期一样每天早起去图书馆，然鹅疫情就这么来了，一切安排都被打乱。19年底我甚至计划20暑假去日本玩些日子，组了小伙伴也做了很多功课，但是照现在的情况来看，扶桑之旅多半是gg了。 &emsp;&emsp;大概4月底会开学吧，说实话宅家虽然没劲儿学，但我是一点不希望开学，原因是多方面的，仁者见仁智者见智就不细写了。不过考研和就业的临近确实让我提了点劲儿，我又开始刷题了，尽管依然菜得抠脚，但终于算是能静下心学习。目前的目标就是PAT甲级吧，原本3月考，因为疫情被延到了6月底，算是多给我几个月时间蹦跶哈哈哈哈。同时还在准备托福和N2，然鹅到现在也没见报名消息，难过。 &emsp;&emsp;为了整这个博客我牺牲了整整一个下午，从纠结Jekyll还是Hexo，到选主题拿不定主意，然后终于选定主题，字号配色又整不好了（整完提交上去排版崩了，又reset）。反正就是完美主义，一次次地推翻自己，不断的装了改、改了删、删了再装，没完没了，我还自己用Procreate手写了个Logo（丢人，估计过几天就得换），大概这也算是一种自虐？（笑） &emsp;&emsp;总而言之，希望自己能坚持下去，定期总结学习、总结生活（虽然语文丢人）。坚守自己21年暑假考日本的目标，趁着年轻再搏一搏，虽然软件行业好像不很重视学历，但考硕确实是实现名校情结的最后机会了！给我冲！頑張る","link":"/2020/04/01/diary/200401-diary/"},{"title":"N皇后（N-Queens）","text":"LeetCode 51 N-Queens LeetCode 52 N-Queens II N-QueensProblem Description&emsp;&emsp;n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 &emsp;&emsp; &emsp;&emsp;上图为 8 皇后问题的一种解法。 &emsp;&emsp;给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。 &emsp;&emsp;每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。 &emsp;&emsp;原题：LeetCode 51 N-Queens Example123456789101112131415输入: 4输出: [ [&quot;.Q..&quot;, // 解法 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, // 解法 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;]]解释: 4 皇后问题存在两个不同的解法。 Thought&emsp;&emsp;题目要求将n个皇后放置在n * n大小的棋盘上，皇后之间不能打架，也就是每行、每列、每条对角线上不能同时有两位皇后。 &emsp;&emsp;思路就是深搜回溯，从第1行开始每次逐列放置皇后，每次放置时对已经放置完成的行进行判断，能放则放，不能放则弃。也就是检查当前位置皇后的上、左上、右上方是否存在皇后。完成n个皇后放置任务后将当前棋盘添加至结果集。 Code&emsp;&emsp;觉得这题难度其实不大，就是个人在效率上有点难受（再见残酷的世界！），第1版写完交上去虽然一次AC了，但时间和空间居然都被95%的人碾压？？？（拐回来看代码发现参数全是形参，改了引用参数后时间击败60%空间击败100%）然后参考老哥们的题解改了改，还凑合吧，粘两个版本留念。 Version 1&emsp;&emsp;直接把整个棋盘开出来了，然后逐行放置皇后。检查已放置的行就开了3个for循环，分别对正上、左上、右上的格子进行遍历判断。 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution {public: bool isValid(vector&lt;string&gt;&amp; bd, int row, int col) { //正上 for(int i = 0; i &lt; row; i++) { if(bd[i][col] == 'Q') return false; } //左上 for(int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--) { if(bd[i][j] == 'Q') return false; } //右上 for(int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; bd.size(); i--, j++) { if(bd[i][j] == 'Q') return false; } return true; } void dfs(vector&lt;string&gt;&amp; bd, int row, int n) { if(row == n) { res.push_back(bd); return; } for(int i = 0; i &lt; n; i++) { if(isValid(bd, row, i)) { bd[row][i] = 'Q'; dfs(bd, row + 1, n); bd[row][i] = '.'; } } } vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) { vector&lt;string&gt; bd(n, string(n, '.')); dfs(bd, 0, n); return res; }private: vector&lt;vector&lt;string&gt;&gt; res;}; Version 2&emsp;&emsp;棋盘是按行开辟的，凑够一整盘后带走放入结果集（空间上没有影响，就是单纯尝试下。。。）。&emsp;&emsp;这个判断比较有意思，是在题解区学的。先开个数组用来存放棋盘每一行放置皇后的列值，在判断时，如果当前列与数组中的列重复，即正上方有皇后。对角线点坐标的x, y与当前点相减的绝对值是相同的，由此判断对角线上是否存在皇后。 123456789101112131415161718192021222324252627282930313233343536373839class Solution {public: bool isValid(int row, int col, vector&lt;int&gt; &amp;pos) { for (int i = 0; i &lt; row; i++) { if (col == pos[i] || abs(row - i) == abs(pos[i] - col)) return false; } return true; } void dfs(int row, int n, vector&lt;int&gt; &amp;pos, string &amp;line) { if (row == n) { res.push_back(tmp); return; } for (int i = 0; i &lt; n; i++) { if (isValid(row, i, pos)) { line[i] = 'Q'; tmp.push_back(line); line[i] = '.'; pos[row] = i; dfs(row + 1, n, pos, line); pos[row] = -1; tmp.pop_back(); } } } vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) { string line(n, '.'); vector&lt;int&gt; pos(n, -1); dfs(0, n, pos, line); return res; }private: vector&lt;vector&lt;string&gt;&gt; res; vector&lt;string&gt; tmp;}; N-Queen IIProblem Description&emsp;&emsp;n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 &emsp;&emsp; &emsp;&emsp;上图为 8 皇后问题的一种解法。 &emsp;&emsp;给定一个整数 n，返回 n 皇后不同的解决方案的数量。 &emsp;&emsp;原题：LeetCode 51 N-Queens II Example12345678910111213141516输入: 4输出: 2解释: 4 皇后问题存在如下两个不同的解法。[ [&quot;.Q..&quot;, // 解法 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, // 解法 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;]] Thought&emsp;&emsp;怎么说呢，我严重怀疑LeetCode的临时工把题号标错了，这个虽然是II，但明显是原版的简化。看见题没多想，直接复制粘贴上一题代码，删掉所有棋盘数据，只保留了存放每行皇后位置的数组，直接上代码。在题解区看到用位运算好像效率蛮高的，改天再看吧（头冷）。 Code12345678910111213141516171819202122232425262728293031class Solution {public: bool isValid(int row, int col, vector&lt;int&gt; &amp;pos) { for (int i = 0; i &lt; row; i++) { if (col == pos[i] || abs(row - i) == abs(pos[i] - col)) return false; } return true; } void dfs(int row, int n, vector&lt;int&gt; &amp;pos, int &amp;res) { if (row == n) { res++; return; } for (int i = 0; i &lt; n; i++) { if (isValid(row, i, pos)) { pos[row] = i; dfs(row + 1, n, pos, res); pos[row] = -1; } } } int totalNQueens(int n) { vector&lt;int&gt; pos(n, -1); int res = 0; dfs(0, n, pos, res); return res; }}; Summary&emsp;&emsp;就是简单的暴力深搜回溯，逻辑上没有什么细节好抠的。虽然LeetCode标记的难度是Hard，但实际其实还好？不过第一次信心满满地交上去，结果时间和空间都只击败5%确实难受（弱鸡枯了），确实自己经常忘打取地址符，尤其是cpp变量名字太长习惯性复制粘贴，就忘了。","link":"/2020/04/08/problem/leetcode/200408-n-queens/"}],"tags":[{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"BackTracking","slug":"BackTracking","link":"/tags/BackTracking/"}],"categories":[{"name":"Diary","slug":"Diary","link":"/categories/Diary/"},{"name":"Problem","slug":"Problem","link":"/categories/Problem/"},{"name":"LeetCode","slug":"Problem/LeetCode","link":"/categories/Problem/LeetCode/"}]}