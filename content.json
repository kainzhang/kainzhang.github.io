{"pages":[],"posts":[{"title":"Github+PicGo+jsDelivr搭建博客图床","text":"&emsp;&emsp;刷CSDN瞟到jsDelivr这个免费CDN，在官网了解一下发现可以加速Github项目。想到GithubPages加载缓慢，就赶紧深入学习。然后我惊奇发现，原来我用的Icarus主题已经用了jsDelivr的CDN，大一时写界面的Bootstrap也用了！它就在身边我居然今天（昨晚）才知道？ &emsp;&emsp;图床是早就有了解的，但是一直没考虑尝试，一方面是懒，另一方面是不想把图片传到别人的空间。现在能用Github做图床，岂不美哉？ 使用Github配置PicGo&emsp;&emsp;流程很简单，在 这里 下载客户端，然后按照 官方文档 一步步来就vans了，写的很详细，我就不瞎扯了。 使用jsDelivr CDN&emsp;&emsp;依然很简单，你甚至 jsDelivr 官网都不用进，直接用走jsDelivr CDN的URL获取图片就好了，在PicGo的Github设置页面设置自定义域名，格式如下。之后上传的图片直接复制URL就是走CDN的了。 https://cdn.jsdelivr.net/gh/&lt;用户名&gt;/&lt;仓库名&gt; 使用中遇到的坑&emsp;&emsp;PicGo间歇性失灵，出现上传失败的话，就关闭重启试试。 总结&emsp;&emsp;用着很爽，不影响我水博文，图片加载速度显著提高。发文章时把图片拖拽到PicGo的上传区，然后在相册点击复制URL即可。就是用Github做图床导致小绿点看着很虚假（嘻嘻）。 unsplash-logoAnton Darius","link":"/2020/05/01/image-hosting/"},{"title":"使用Travis CI部署Hexo博客","text":"&emsp;&emsp;使用Travis CI部署Hexo博客是Hexo官方文档推荐的部署方法，但是博客源文件会被公开。起初就是因为这一点没有使用Travis CI部署，但是刚成功部署完Hexo发了第一篇博文后我就在想，博客源文件都在本地，如果我换电脑了或者源文件不在身边或者电脑坏了怎么办？岂不是很麻烦？我这么怕麻烦个人… &emsp;&emsp;当时就搜了这个问题，果然大佬们早就提供了解决方案。一般都是把源文件也放在github，或者推送到分支。我想既然都放到分支上了，不如直接按官方推荐的，用Travis CI部署，这样甚至可以随时随地修改博文，即便本地没有环境，也可以把md交到仓库即时发布。 关于Travis CI&emsp;&emsp;Travis CI提供持续集成服务，目前仅支持Github项目。它提供环境帮用户构建、测试、部署项目，在你提交代码后，它会clone你的项目，配置环境并安装依赖，然后返回运行结果。具体内容请查阅 官方文档。 &emsp;&emsp;放到Github Pages部署的Hexo来说，就是当你的Hexo项目有改变时，它会帮你生成静态文件，并部署到你指定的项目分支。 部署Hexo&emsp;&emsp;Hexo官方文档 提供了详细的步骤，我就记录一些遇到的坑吧。 分支问题&emsp;&emsp;按照Hexo官方文档的步骤，Hexo项目被推送到项目Master分支，然后由Travis CI将静态文件发布至gh-pages分支，在Github Pages设定中选择gh-pages分支进行部署。我记得不久前Github Pages还是可以自行选择分支的，但现在仅支持部署Master分支了，如图。 &emsp;&emsp;也就是说Master分支要放静态文件，另开一个分支放源文件。第一次部署Hexo的朋友需要注意这个问题，对于已经把静态文件推送到Master分支的朋友来说，没有任何影响，源文件直接推送新的分支就vans了。 12345git initgit add .git commit -m \"init blog\"git remote add origin https://github.com/&lt;用户名&gt;/&lt;用户名&gt;.github.io.gitgit push origin master:hexo &emsp;&emsp;注意配置.travis.yml，这里把源文件推送到hexo分支。 .travis.yml12345678910111213141516171819sudo: falselanguage: node_jsnode_js: - 10cache: npmbranches: only: - hexo # 对Hexo分支进行构建script: - hexo generatedeploy: provider: pages skip-cleanup: true github-token: $GH_TOKEN target-branch: master # 设置部署的目标分支 keep-history: true on: branch: hexo local-dir: public 仓库冲突问题&emsp;&emsp;按照官方文档操作完毕，.travis.yml也配置完成，使用脚本一套操作把文件推送到Github，默默等待Travis CI部署我的博客。刷新浏览器检验是否成功，居然白板？？赶紧查Travis CI的记录，提示no layout，仓库内的主题文件没有被推送导致静态文件压根没生成！ &emsp;&emsp; &emsp;&emsp;拐回来看被我无视的bash记录，项目内居然有关联别的仓库？是clone icarus主题时带来的。根据提示输入 git rm –cached themes/icarus 是不行的，icarus目录内存在.git 目录需要删除。 &emsp;&emsp; &emsp;&emsp;进入icarus目录直接删除文件夹。问题解决。 gitignore问题&emsp;&emsp;解决仓库冲突问题后，我又推送了，这回推送过程没问题，Travis CI构建静态文件倒是出了问题。刷新浏览器依然时白板，Travsi CI记录是这样的。 &emsp;&emsp; &emsp;&emsp;icarus主题目录里缺了配置文件_config.yml,当icarus发现目录内没有配置文件时会自动创一个，这锅必须是.gitignore的，点开文件发现里面赫然记录着_config.yml,赶紧删掉！ 总结&emsp;&emsp;Travis CI能够提供环境，帮助构建、测试及部署Hexo项目，使用Travis CI部署博客满足了随时随地修改内容的强迫症需求，解决了出差、旅游时不方便水博文的问题，也解决了随着博客内容不断增多造成的生成及推送静态文件时的等待问题（虽然并不多）。优雅地推送源文件就vans了，或者在仓库添加/修改md文件。暂时还没有尝试在其他主机配置Hexo本地文件。以上。 unsplash-logoMichael Liao","link":"/2020/05/02/travis-ci-deploy-hexo/"},{"title":"设计模式 - 工厂模式（Factory Pattern）","text":"&emsp;&emsp;Java设计模式 - 工厂模式 简单工厂模式简单工厂模式组成： 工厂类：简单工厂模式的核心，负责创建所需的产品实例。 抽象产品类：产品类的父类，定义产品类共有的属性和方法。 产品类： 继承抽象产品类，即具体的产品。 &emsp;&emsp;首先定义抽象咖啡类，规定所有咖啡共有的接口。 123456789101112131415public abstract class Coffee { protected String name; // 制作咖啡 public void prepare() { System.out.println(name + \"制作完成！\"); } // 打包咖啡 public void pack() { System.out.println(name + \"打包完成!\"); }} &emsp;&emsp;定义具体类型的咖啡。 1234567891011121314151617public class Americano extends Coffee{ public Americano() { this.name = \"美式\"; }}public class Latte extends Coffee{ public Latte() { this.name = \"拿铁\"; }}public class Mocha extends Coffee{ public Mocha() { this.name = \"摩卡\"; }} &emsp;&emsp;创建咖啡工厂类，负责具体产品的实例化 1234567891011121314public class CoffeeFactory { public Coffee createCoffee(String coffeeType) { Coffee coffee = null; if (coffeeType.equals(\"美式\")) { coffee = new Americano(); } else if (coffeeType.equals(\"拿铁\")) { coffee = new Latte(); } else if (coffeeType.equals(\"摩卡\")) { coffee = new Mocha(); } return coffee; }} &emsp;&emsp;咖啡馆类调用咖啡工厂类。 123456789101112131415161718192021222324public class Cafe { private static String getCoffeeType() { try { BufferedReader strin = new BufferedReader(new InputStreamReader(System.in)); System.out.println(\"请输入咖啡类别：\"); String str = strin.readLine(); return str; } catch (IOException e) { e.printStackTrace(); return \"\"; } } public static void main(String[] args) { CoffeeFactory cf = new CoffeeFactory(); String coffeeType = getCoffeeType(); Coffee coffee = cf.createCoffee(coffeeType); if (coffee != null) { coffee.prepare(); coffee.pack(); } else { System.out.println(\"请求失败！\"); } }} unsplash-logoTyler Nix","link":"/2020/04/25/factory-pattern/"},{"title":"First diary, Hello world!","text":"&emsp;&emsp;很早就想搞个博客记录学习和生活，留给未来回首往日。Emmm…之所以拖到今天才开始着手，一方面是因为疫情一直宅家想充实，一方面是面临考研，发现自己两年半来居然一点学习笔记也没留下。想想CXK练习时长两年半都出道了，自己考研前的寒假还爆肝了四五周游戏（u1s1，DQB2是真的香），爆肝之后的贤者模式告诉我，不能继续在游戏中堕落下去（该换个方式堕落了)，这也是为什么我会在这里用小学作文的水平码字。。。 &emsp;&emsp;产生这个想法是在大一时期，当时在老师的倡导下在学校OJ刷题，经常刷到凌晨（虽然水平没提升的多少，但头顶确实越来越冷了），题目怼不出来就复制题号在网上搜，也由此见识了很多大佬的CSDN、博客园博客，惊叹于大佬的解题能力和刷题量，也包括很多大佬的学习笔记、随笔 blahblah，当时就想着什么时候咱也得整一个！ &emsp;&emsp;然鹅只恨自己太懒，大一下学期题几乎不刷题了，很少再去搜题解（了解到学院不参加ACM，觉得刷题失去意义）。大二虽然学院突然开始参加比赛了，但糟糕的时间安排和被各种破事占用时间，刷题都没得刷，更别提写博客了，于是博客计划无限期搁置。。。 &emsp;&emsp;2020的寒假意外得长，寒假前我还计划像以往假期一样每天早起去图书馆，然鹅疫情就这么来了，一切安排都被打乱。19年底我甚至计划20暑假去日本玩些日子，组了小伙伴也做了很多功课，但是照现在的情况来看，扶桑之旅多半是gg了。 &emsp;&emsp;大概4月底会开学吧，说实话宅家虽然没劲儿学，但我是一点不希望开学，原因是多方面的，仁者见仁智者见智就不细写了。不过考研和就业的临近确实让我提了点劲儿，我又开始刷题了，尽管依然菜得抠脚，但终于算是能静下心学习。目前的目标就是PAT甲级吧，原本3月考，因为疫情被延到了6月底，算是多给我几个月时间蹦跶哈哈哈哈。同时还在准备托福和N2，然鹅到现在也没见报名消息，难过。 &emsp;&emsp;为了整这个博客我牺牲了整整一个下午，从纠结Jekyll还是Hexo，到选主题拿不定主意，然后终于选定主题，字号配色又整不好了（整完提交上去排版崩了，又reset）。反正就是完美主义，一次次地推翻自己，不断的装了改、改了删、删了再装，没完没了，我还自己用Procreate手写了个Logo（丢人，估计过几天就得换），大概这也算是一种自虐？（笑） &emsp;&emsp;总而言之，希望自己能坚持下去，定期总结学习、总结生活（虽然语文丢人）。坚守自己21年暑假考日本的目标，趁着年轻再搏一搏，虽然软件行业好像不很重视学历，但考硕确实是实现名校情结的最后机会了！给我冲！頑張る","link":"/2020/04/01/hello-world/"},{"title":"使用分支限界法解决0/1背包问题","text":"&emsp;&emsp;在算法分析课上第一次接触分支限界法（Branch &amp; Bound），实验要求使用分支限界法解决01背包问题。虽然很清楚代码量要远高于DP，但报告是还要写的，硬着头皮怼吧。随便在蓝桥杯题库找了一道01背包的基础题做测试，题目是算法训练的 ALGO-30 入学考试。 题目问题描述&emsp;&emsp;辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”&emsp;&emsp;如果你是辰辰，你能完成这个任务吗？ 输入格式&emsp;&emsp;第一行有两个整数T（1 &lt;= T &lt;= 1000）和M（1 &lt;= M &lt;= 100），用一个空格隔开，T代表总共能够用来采药的时间，M代表山洞里的草药的数目。接下来的M行每行包括两个在1到100之间（包括1和100）的整数，分别表示采摘某株草药的时间和这株草药的价值。 输出格式&emsp;&emsp;包括一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。 样例输入123470 371 10069 11 2 样例输出13 数据规模和约定&emsp;&emsp;对于30%的数据，M &lt;= 10； &emsp;&emsp;对于全部的数据，M &lt;= 100。 解题思想分支限界法概述 &emsp;&emsp;分支限界法常以广度优先或以最小耗费（最大效益）优先的方式搜索问题的解空间树。&emsp;&emsp;在分支限界法中，每一个活结点只有一次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生其所有儿子结点。在这些儿子结点中，导致不可行解或导致非最优解的儿子结点被舍弃，其余儿子结点被加入活结点表中。&emsp;&emsp;此后，从活结点表中取下一结点成为当前扩展结点，并重复上述结点扩展过程。这个过程一直持续到找到所需的解或活结点表为空时为止。 &emsp;&emsp;对于01背包问题来说，就是每访问一个结点，生成两个儿子结点，一个是放入物品，一个是舍弃物品。在生成结点的同时判断该结点是否为可行解，并同时计算该结点下的上界。对于不可行解直接剪枝，可行结点使用优先队列存储。不断扩展队列优先级最高的结点，也就是上界最大的结点，当优先队列中优先级最高的结点上界不大于已知的值时，循环结束，当前得到的最优值即为所求最优值。 具体思路&emsp;&emsp;放到本题来看，每个草药包括两个属性：采集时间和价值。首先将所有草药按单位时间的价值从高到低排序，使用二叉树构造解空间树，每层结点代表正在放置第几个草药。由此，每个结点将能够扩展两个子节点，即放入N号草药和不放入N号草药。分别为每个扩展的结点计算上界，即计算规定时间内可拆分条件下的最大价值。如果当前结点的时间超出给定总时间T或者上界小于当前已知最优值，则剪枝处理，其余放入优先队列。 &emsp;&emsp;设定优先队列为大顶堆的数据结构，不断从优先队列中取出优先级最高（上界大于已知最优值）的结点，对其扩展。如果该结点已扩展至叶结点（所在路径已遍历所有草药），则与当前已知最优值比较，取最大值。当队列中所有结点的上界均不大于当前已知最优值时，循环结束。计算过程和解空间树如下图。 &nbsp;&nbsp;剪枝策略：采摘当前草药导致超时，或当前结点上界小于已知最优值时剪枝。 AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;using namespace std;struct Herb { int tim, val; // 时间，价值 bool operator &gt; (const Herb &amp;x) const { return (val * 1.0 / tim) &gt; (x.val * 1.0 / x.tim); }};struct Node { int nxt, sumT, sumV; // 下一药草的序号 当前总时间 当前总价值 double maxV; // 该结点的上界 bool operator &lt; (const Node &amp;x) const { return maxV &lt; x.maxV; // 优先队列内按上界从高到低排序 }};int T, M;vector&lt;Herb&gt; hrbs;priority_queue&lt;Node&gt; que;double bound(int i, int sumT, int sumV) { double res = sumV; int leftT = T - sumT; // 剩余时间 while (i &lt; M &amp;&amp; hrbs[i].tim &lt;= leftT) { // 在时间允许的条件下不断放入 leftT -= hrbs[i].tim; sumV += hrbs[i].val; i++; } if (i &lt; M) { res = sumV + leftT * (hrbs[i].val * 1.0 / hrbs[i].tim); } return res;}int solve() { int res = 0; Node r = {0, 0, 0, bound(0, 0, 0)}; que.push(r); // 放入根结点 while (que.top().maxV &gt; res) { // 堆顶结点的上界大于已知最优值 Node n = que.top(); que.pop(); if (n.nxt == M) { res = max(res, n.sumV); // 获取实际最优值 } else { Node n2 = n; // 复制一个 if (n.sumT + hrbs[n.nxt].tim &lt;= T) { // 超时剪掉 n.maxV = bound(n.nxt, n.sumT, n.sumV); // 放入当前草药时的上界 if (n.maxV &gt; res) { n.sumT += hrbs[n.nxt].tim; // 修改当前时间 n.sumV += hrbs[n.nxt].val; // 修改当前价值 n.nxt++; que.push(n); } } n2.maxV = bound(n2.nxt + 1, n2.sumT, n2.sumV); // 不放当前草药时的上界 if (n.maxV &gt; res) { // 上界小于当前已知最优值则剪枝 n2.nxt++; que.push(n2); } } } return res;}int main() { scanf(\"%d %d\", &amp;T, &amp;M); Herb h; for (int i = 0; i &lt; M; i++) { scanf(\"%d %d\", &amp;h.tim, &amp;h.val); hrbs.push_back(h); } sort(hrbs.begin(), hrbs.end(), greater&lt;Herb&gt;()); // 按单位时间价值排序 cout &lt;&lt; solve() &lt;&lt; endl;} 扯淡&emsp;&emsp;纯按自己的理解写的，所以不清楚代码是否规范。交上去顺利AC了，起初数据量较大的两个测试用例用了15ms，后来稍微优化下全部0ms通过了。代码量有点大，不过效率比想象要高，其实还是DP效果好。算法思想是跟着油管的印度大叔 Abdul Bari 学的。视频地址：0/1 Knapsack using Branch and Bound","link":"/2020/05/22/01-knapsack-using-branch-n-bound/"},{"title":"PAT-A 1081 Rational Sum (20)","text":"&nbsp;&nbsp;记录一次被水题的测试点教做人的经历，果然还是差得远。 Given N rational numbers in the form numerator/denominator, you are supposed to calculate their sum. Problem:&nbsp;PAT-A 1081 Rational Sum Input SpecificationEach input file contains one test case. Each case starts with a positive integer N (≤100), followed in the next line N rational numbers a1/b1 a2/b2 … where all the numerators and denominators are in the range of long int. If there is a negative number, then the sign must appear in front of the numerator. Output SpecificationFor each test case, output the sum in the simplest form integer numerator/denominator where integer is the integer part of the sum, numerator &lt; denominator, and the numerator and the denominator have no common factor. You must output only the fractional part if the integer part is 0. Sample 1Input 1252/5 4/15 1/30 -2/60 8/3 Output 13 1/3 Sample 2Input 1224/3 2/3 Output 12 Sample 3Input 1231/3 -1/6 1/8 Output 17/24 Analysis&emsp;&emsp;简单的分数加法运算，需要对分数进行化简，即计算最大公约数。测试点只有5个，虽然没有涉及分母为0的情况，但对输出格式抠得还是很死的。输出格式有以下几种。 整数部分为0，分子部分不为0，输出分数 整数部分不为0，分子部分为0，输出整数 整数部分不为0，分子部分不为0，输出整数 + 分数 整数部分和分子部分均为0，输出一个0 &nbsp;&nbsp;两个分数相加时会出现溢出，long long不够用，需要先化简。 Code12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;int gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b);}int main() { int N, num, numS = 0, den, denS = 1; scanf(\"%d\", &amp;N); for (int i = 0; i &lt; N; i++) { scanf(\"%d/%d\", &amp;num, &amp;den); numS = numS * den + denS * num; denS = denS * den; int t = gcd(abs(numS), abs(denS)); numS /= t; denS /= t; } int itg = numS / denS; // 获得整数部分 numS %= denS; if (itg != 0) { printf(\"%d\", itg); // 输出非 0 整数部分 if (numS == 0) return 0; // 分子为 0, 结束 printf(\" \"); } if (numS == 0) { // 整数, 分子均为 0 printf(\"0\"); } else { // 分子不为零 printf(\"%d/%d\", numS, denS); }} Tsukkomi&emsp;&emsp;一开始写的时候没有划清4种输出格式，代码写得很乱，拆东墙补西墙，就完全自己挖坑往里跳。后来受不了了直接重写了输出部分，重新理一遍写出来交上去，始终就有一个测试点过不了。 &emsp;&emsp;起初我的循环部分是下面这么写的，一直有一个测试点通过不能，核对了半天输出格式，编了各种测试用例都没问题，每次交上去就是有一个不过。网上搜别人的核对后确认输出都是正确的，然后才想到是不是溢出了。给第一个输入的分数添加了化简操作，就过了…… 12345678910ll num, numS, den, denS;scanf(\"%d %lld/%lld\", &amp;N, &amp;numS, &amp;denS);for (int i = 1; i &lt; N; i++) { scanf(\"%lld/%lld\", &amp;num, &amp;den); numS = numS * den + denS * num; denS *= den; t = gcd(abs(numS), abs(denS)); numS /= t; denS /= t;}","link":"/2020/05/26/pat-a-1081/"},{"title":"PAT-A 1148 Werewolf - Simple Version (20)","text":"&nbsp;&nbsp;狼人杀简单版，暴力枚举 Werewolf（狼人杀） is a game in which the players are partitioned into two parties: the werewolves and the human beings. Suppose that in a game, player #1 said: “Player #2 is a werewolf.”; player #2 said: “Player #3 is a human.”; player #3 said: “Player #4 is a werewolf.”; player #4 said: “Player #5 is a human.”; and player #5 said: “Player #4 is a human.”. Given that there were 2 werewolves among them, at least one but not all the werewolves were lying, and there were exactly 2 liars. Can you point out the werewolves? Now you are asked to solve a harder version of this problem: given that there were N players, with 2 werewolves among them, at least one but not all the werewolves were lying, and there were exactly 2 liars. You are supposed to point out the werewolves. Problem:&nbsp;PAT-A 1148 Werewolf - Simple Version Input SpecificationEach input file contains one test case. For each case, the first line gives a positive integer N (5 ≤ N ≤ 100). Then N lines follow and the i-th line gives the statement of the i-th player (1 ≤ i ≤ N), which is represented by the index of the player with a positive sign for a human and a negative sign for a werewolf. Output SpecificationIf a solution exists, print in a line in ascending order the indices of the two werewolves. The numbers must be separated by exactly one space with no extra spaces at the beginning or the end of the line. If there are more than one solution, you must output the smallest solution sequence – that is, for two sequences A=a[1],…,a[M] and B=b[1],…,b[M], if there exists 0 ≤ k &lt; M such that a[i] = b[i] (i ≤ k) and a[k+1]&lt;b[k+1], then A is said to be smaller than B. In case there is no solution, simply print No Solution. Sample 1Input 1234565-2+3-4+5+4 Output 11 4 Sample 2Input 12345676+6+3+1-5-2+4 Output 11 5 Sample 3Input 1234565-2-3-4-5-1 Output 1No Solution Analysis题目划重点： N 个玩家中有 2 个狼人 至少 1 个狼人说谎 不是所有狼人都说谎 有 2 个玩家说谎 &emsp;&emsp;也就是说，说谎的 2 个玩家中 1 个狼人 1 个人类。题目要求输出 2 个狼人的序号，因此枚举所有可能的 2 个狼人的组合，检查该组合下的说谎玩家数及身份，如果恰为 2 个玩家说谎且 1 个狼人 1 个人类，即为所求解。 Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(0); int N; cin &gt;&gt; N; vector&lt;int&gt; vec(N + 1); for (int i = 1; i &lt;= N; i++) { cin &gt;&gt; vec[i]; } // 枚举所有可能的狼人组合 for (int i = 1; i &lt;= N; i++) { for (int j = i + 1; j &lt;= N; j++) { // sign记录身份，liar保存说谎者 vector&lt;int&gt; sign(N + 1, 1), liar; // 假设 i, j为狼人 sign[i] = sign[j] = -1; // 自己说的与事实不符，记为说谎者 for (int k = 1; k &lt;= N; k++) { if (sign[abs(vec[k])] * vec[k] &lt; 0) { liar.push_back(k); } } // 说谎者数量为 2，且 1 狼人 1 人类，则 i, j为狼人成立 if (liar.size() == 2 &amp;&amp; sign[liar[0]] * sign[liar[1]] &lt; 0) { cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; j &lt;&lt; endl; return 0; } } } cout &lt;&lt; \"No Solution\" &lt;&lt; endl;} Tsukkomi&emsp;&emsp;没有读清题就开始写了，半路才发现说谎的玩家中1个狼人1个人类。想着能不能用什么巧妙的方法得出结果，无奈太笨。网上搜了搜大佬的解法才知道直接暴力枚举就 vans 了。","link":"/2020/07/02/pat-a-1148/"},{"title":"PAT-A 1003 Emergency (25)","text":"&nbsp;&nbsp;图的 Dijkstra 算法，在算法基础上增加最大点权和以及最短路径条数的记录。 As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible. Problem:&nbsp;PAT-A 1003 Emergency Input SpecificationEach input file contains one test case. For each test case, the first line contains 4 positive integers: N (≤ 500) - the number of cities (and the cities are numbered from 0 to N − 1), M - the number of roads, C1 and C2 - the cities that you are currently in and that you must save, respectively. The next line contains N integers, where the i-th integer is the number of rescue teams in the i-th city. Then M lines follow, each describes a road with three integers c​1, c2 and L, which are the pair of cities connected by a road and the length of that road, respectively. It is guaranteed that there exists at least one path from C​1 to C2. Output SpecificationFor each test case, print in one line two numbers: the number of different shortest paths between C1 and C2, and the maximum amount of rescue teams you can possibly gather. All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line. SampleInput 123456785 6 0 21 2 1 5 30 1 10 2 20 3 11 2 12 4 13 4 1 Output 12 4 Analysis&emsp;&emsp;单源最短路径问题，用 Dijkstra 算法。根据题意，每个城市的救援队数量为点权，城市之间的距离为边权。由于题目要求输出结果为最短路径数和最大点权和，添加 num 数组记录起点至各顶点的最短路径数，添加 w 数组记录起点至各个顶点的最大点权和，在计算 d 的同时更新上述两个数组，详情见代码注释。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;const int mxN = 505;// N:顶点数, M:边数, C1:起点, C2:终点int N, M, C1, C2;// G:邻接矩阵, d:起点至各点的最短距离, weight:点权, w:最大点权和, num:最短路径条数int G[mxN][mxN], d[mxN], weight[mxN], w[mxN], num[mxN];bool vis[mxN] = {false};void dijkstra(int s) { // s 为起点 fill(d, d + N, INT_MAX); // 初始化 d 数组 d[s] = 0; // 起点到自身距离为 0 w[s] = weight[s]; // 起点最大点权 num[s] = 1; // 起点至起点路径数为 1 for (int i = 0; i &lt; N; i++) { int u = -1, MIN = INT_MAX; // 遍历 N 个点, 寻找最小 d[]和对应顶点 for (int j = 0; j &lt; N; j++) { if (!vis[j] &amp;&amp; d[j] &lt; MIN) { MIN = d[j]; u = j; } } if (u == -1) return; // 未找到通路，剩下的顶点与起点不通 vis[u] = true; // 标记 u 已访问 for (int v = 0; v &lt; N; v++) { // 如果 v 未访问, 且 u - v 连通 if (!vis[v] &amp;&amp; G[u][v] != INT_MAX) { // 如果以 u 为中介点至 v 的距离小于已知 d[v] if (d[u] + G[u][v] &lt; d[v]) { d[v] = d[u] + G[u][v]; // 更新 d[v] w[v] = w[u] + weight[v]; // 更新点权和 num[v] = num[u]; // 更新路径数 } else if (d[u] + G[u][v] == d[v]) { // 路径长度相同 w[v] = max(w[v], w[u] + weight[v]); // 比较获取最大点权 num[v] += num[u]; // 路径数累加 } } } }}int main() { ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; N &gt;&gt; M &gt;&gt; C1 &gt;&gt; C2; // 读入点权, 即每个城市的救援队数量 for (int i = 0; i &lt; N; i++) { cin &gt;&gt; weight[i]; } // 初始化图 G, 边权为无穷大 fill(G[0], G[0] + mxN * mxN, INT_MAX); // 读入边权, 即每两个城市的距离, 无向图双向赋值 for (int i = 0; i &lt; M; i++) { int u, v, l; cin &gt;&gt; u &gt;&gt; v &gt;&gt; l; G[u][v] = G[v][u] = l; } dijkstra(C1); cout &lt;&lt; num[C2] &lt;&lt; \" \" &lt;&lt; w[C2] &lt;&lt; endl;} Tsukkomi&emsp;&emsp;Dijkstra 基本快忘了，思想是明白的，但写出来有点费劲。之前用到的时候也是直接比着模板写的，但为了准备 PAT 考试，就硬学呗。代码参考了胡凡的《算法笔记》，书上正好有这道题的讲解，很是详细。","link":"/2020/07/03/pat-a-1003/"},{"title":"PAT-A 1010 Radix (25)","text":"&nbsp;&nbsp;进制转换问题，又被测试用例教做人了。 Given a pair of positive integers, for example, 6 and 110, can this equation 6 = 110 be true? The answer is yes, if 6 is a decimal number and 110 is a binary number. Now for any pair of positive integers N1 and N2, your task is to find the radix of one number while that of the other is given. Problem:&nbsp;PAT-A 1010 Radix Input SpecificationEach input file contains one test case. Each case occupies a line which contains 4 positive integers: N1 N2 tag radix Here N1 and N2 each has no more than 10 digits. A digit is less than its radix and is chosen from the set { 0-9, a - z } where 0-9 represent the decimal numbers 0-9, and a - z represent the decimal numbers 10-35. The last number radix is the radix of N1 if tag is 1, or of N2 if tag is 2. Output SpecificationFor each test case, print in one line the radix of the other number so that the equation N1 = N2 is true. If the equation is impossible, print Impossible. If the solution is not unique, output the smallest possible radix. Sample 1Input 16 110 1 10 Output 12 Sample 2Input 11 ab 1 2 Output 1Impossible Analysis&emsp;&emsp;给两个数，已知其中一个数的基数，判断另一个数是否存在基数使两个数相等，求出该基数，不存在则输出 Impossible。从题意来看就是普通的进制转换，先求出已知基数的数的 10 进制，再求出另一个数在不同基数下转为 10 进制的值，比较两数大小，如果相等则当前基数为所求解。但是测试点很恐怖，参考了大佬的代码才全过。遇到以下坑： 题目未说明 基数取值范围。实际下限大于未知基数的数中的任何一个数字，上限为已知基数的数，并不是简单的数字 + 字母的 [2, 35]。 题目只说明了数最大有 10 位，所以 int 显然不够存了，而且如果基数比较大，那么 long long 也不够存。根据前辈们的踩坑经历，幸好测试用例中所有数据都在 long long 范围内，不然就太折腾了。 由于基数可能非常大，从小到大一个个遍历会有一个测试点过不去，因此搜索基数的时候采用 二分查找，使用的上限和下限也就是基数的取值范围。 二分查找的过程中会出现 long long 溢出 导致返回值为负数，查找时要增加判断。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;// 字符串转 10 进制ll str_to_dec(string str, ll radix) { ll res = 0; int len = str.size(); for (int i = 0; i &lt; len; i++) { int tmp = (isdigit(str[i]) ? str[i] - '0' : str[i] - 'a' + 10); res += tmp * pow(radix, len - i - 1); } return res;}// 获取基数ll get_radix(string str, ll num) { // num 为已知数的 10 进制 ll radix = 0; // 计算基数范围 char maxC = *max_element(str.begin(), str.end()); // 找到最大字符 ll lo = (isdigit(maxC) ? maxC - '0' : maxC - 'a' + 10) + 1; ll hi = max(lo, num); // 使用二分查找计算基数 while (lo &lt;= hi) { ll mid = (lo + hi) / 2; ll tmp = str_to_dec(str, mid); if (tmp &gt; num || tmp &lt; 0) { // 比已知数大或向上溢出 hi = mid - 1; } else if (tmp &lt; num) { // 比已知数小 lo = mid + 1; } else { radix = mid; break; } } return radix;}int main() { string N1, N2; int tag, radix; cin &gt;&gt; N1 &gt;&gt; N2 &gt;&gt; tag &gt;&gt; radix; ll num = (tag &amp; 1) ? str_to_dec(N1, radix) : str_to_dec(N2, radix); ll ans = (tag &amp; 1) ? get_radix(N2, num) : get_radix(N1, num); if (ans) { cout &lt;&lt; ans &lt;&lt; endl; } else { cout &lt;&lt; \"Impossible\" &lt;&lt; endl; }} Tsukkomi&emsp;&emsp;测试点太恶心（个人太菜），题目表述也不清（还是个人太菜）。折腾一下午，看着 20 个测试点的结果不断变换，始终有几个点过不去，心态爆炸。嫖完大佬的思路拐回来写，顿时觉得也没什么难度了，主要还是菜。","link":"/2020/07/04/pat-a-1010/"},{"title":"PAT-A 1021 Deepest Root (25)","text":"&nbsp;&nbsp;DFS 遍历无向图；计算树的深度；计算连通分量个数。 A graph which is connected and acyclic can be considered a tree. The height of the tree depends on the selected root. Now you are supposed to find the root that results in a highest tree. Such a root is called the deepest root. Problem:&nbsp;PAT-A 1021 Deepest Root Input SpecificationEach input file contains one test case. For each case, the first line contains a positive integer N (≤ 10^4) which is the number of nodes, and hence the nodes are numbered from 1 to N. Then N−1 lines follow, each describes an edge by given the two adjacent nodes’ numbers. Output SpecificationFor each test case, print each of the deepest roots in a line. If such a root is not unique, print them in increasing order of their numbers. In case that the given graph is not a tree, print Error: K components where K is the number of connected components in the graph. Sample 1Input 1234551 21 31 42 5 Output 123345 Sample 2Input 1234551 31 42 53 4 Output 1Error: 2 components Analysis&emsp;&emsp;判断无向图能否构成树结构，即是否为连通图、不成环。判断方法为计算无向图连通分量个数，如果大于 1 则为非连通图，输入错误结果。 &emsp;&emsp;使用两次 DFS 遍历无向图。第一次遍历选择任意结点作为树根，搜索到当前最深层的叶子结点，同时记录深度相同的叶子结点。第二次遍历，选择第一次遍历解集中的任意结点（最深层的叶子反过来也可以作为树根）作为根结点，获得第二次遍历的解集。两次遍历的解集取并集，使用 set 保存解集，去重并自动排序。 &nbsp;&nbsp;第一次遍历使用任意结点作为树根得出的最深层数不一定为最深。例如样例 1 从结点 1 开始遍历，获得最深层数为 3，即 1 -&gt; 2 -&gt; 5，而以 5 为树根进行遍历最深层数为 4，即 5 -&gt; 2 -&gt; 1 -&gt; 3(4)。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;using namespace std;const int mxN = 1e4 + 5;vector&lt;int&gt; G[mxN], tmp; // 无向图, 临时解集vector&lt;bool&gt; vis(mxN);int max_h = 0;void dfs(int idx, int h) { vis[idx] = true; if (h &gt; max_h) { max_h = h; tmp.clear(); tmp.push_back(idx); } else if (h == max_h) { tmp.push_back(idx); } // 遍历当前结点所有子结点 for (auto it = G[idx].begin(); it != G[idx].end(); it++) { if (vis[*it]) continue; dfs(*it, h + 1); }}int main() { ios::sync_with_stdio(false); cin.tie(0); int N; cin &gt;&gt; N; for (int i = 1; i &lt; N; i++) { int a, b; cin &gt;&gt; a &gt;&gt; b; G[a].push_back(b); G[b].push_back(a); } int K = 0; // 统计连通分量 for (int i = 1; i &lt;= N; i++) { if (!vis[i]) { dfs(i, 0); K++; } } if (K &gt; 1) { // 连通分量大于 1, 非连通图, 输出错误 cout &lt;&lt; \"Error: \" &lt;&lt; K &lt;&lt; \" components\" &lt;&lt; endl; return 0; } // 保存第一次遍历的解集 set&lt;int&gt; ans(tmp.begin(), tmp.end()); // 第二次深搜 fill(vis.begin(), vis.begin() + N + 1, false); dfs(tmp[0], 0); // 保存第二次遍历的解集 for (auto it = tmp.begin(); it != tmp.end(); it++) { ans.insert(*it); } for (auto it = ans.begin(); it != ans.end(); it++) { cout &lt;&lt; *it &lt;&lt; endl; }} Tsukkomi&emsp;&emsp;没什么好吐槽的，继续学习。","link":"/2020/07/05/pat-a-1021/"},{"title":"Github+Coding双托管Hexo及自定义域名","text":"&emsp;&emsp;为了改善加载速度分别尝试了Coding和Gitee的托管以及CloudFlare的CDN加（减）速。无奈都不太乐观，倒是把博客同时托管在Coding，多了个备胎这样子。国内的CDN都要求必须备案，不想备案就只能走境外CDN或者只使用DNS解析。 &emsp;&emsp;心血来潮买了个域名，迫不及待把它绑定到博客。这个.me的黑山国家域名我还蛮喜欢，虽然觉得.cc更可爱些，但个人博客果然是.me比较合适（上面thumbnail是黑山的科托尔）。于是博客迎来全新域名 lokka.me。 使用Coding托管Hexo创建项目&emsp;&emsp;首先就是注册 Coding 账号，创建仓库，操作流程和Github一样，项目模板选择代码托管项目。项目名称随你，项目封面随你，其他的默认就好。Coding没要求必须公开源代码，README也可不添加。 &emsp;&emsp; 本地Hexo设置&emsp;&emsp;进入建好的仓库页面，复制页面右边提供的仓库SSH地址。 &emsp;&emsp; &emsp;&emsp;将SSH粘贴至Hexo的_config.yml对应位置，换行加上就行，注意格式。没错，加上Gitee三托管也可以的，喜欢就只管加上。下次hexo d的时候就会一起发布。 &emsp;&emsp; 添加SSH公钥&emsp;&emsp;为了方便发布，把之前搞GithubPages生成的SSH密钥添加到Coding，SSH密钥一般藏在下面这个位置。 C:\\Users\\用户名\\.ssh\\id_rsa.pub &emsp;&emsp;在Coding页面右上角的弹框里找到 个人设置，然后添加 SSH公钥，复制粘贴确认即可。之后使用hexo d发布时会需要确认，直接回复yes。 静态页面部署&emsp;&emsp;Hexo生成的静态网页成功发布到Coding仓库后进入项目页面，页面左下角找到项目设置 -&gt; 项目与成员 -&gt; 功能开关，然后打开 持续集成 和 持续部署（部署静态页面必须项）。 &emsp;&emsp; &emsp;&emsp;开启上述两项功能后，回到项目主页，左边目录多了持续集成和持续部署两个选项，找到 静态网站，点击立即部署即可。Coding会自动生成一个地址（我看网上别人的都是coding.me的域名，可能现在改版就没了），然后就发布成功啦!点开那个丑陋的地址看看吧！ &emsp;&emsp; 自定义域名&emsp;&emsp;CodingPages生成的域名实在不能接受，赶！紧！买！域！名！ 购买域名&emsp;&emsp;年幼无知的我没做足功课就把第一次献给了 GoDaddy，在这里建议萌新在购买域名前，一定要先在 domcomp 查询一下，这里可以查到你喜欢的域名的最便宜价格及提供该价格的注册商，也可以顺便选一下顶级域名。除了GoDaddy外，部分注册商如 dynadot 也是支持支付宝的。 &emsp;&emsp;由于我是之后才知道domcomp的，已经在GoDaddy买过了。购买流程就是选域名，加购物车，然后结账时候顺便注册账号，选择支付宝，掏出手机扫码付款，按提示来就vans了。GoDaddy的隐私保护是收费的，如果不购买的话，查询whois是可以看到你姓名、电话和邮箱的。不怕信息公开当然可以不买，但是有些注册商比如Porkbun、Dynadot、NameSilo、NameCheap等等一般会免费赠送隐私保护。GoDaddy这里每年除了续费贵，隐私保护也是按年交的，当然不差钱就无所谓啦。 绑定域名&emsp;&emsp;购买成功后找到购买的域名，点击 DNS管理，配置CNAME记录值为CodingPages的地址,CNAME名称填 @ 就好。如果想解析到GithubPages，同理。 &emsp;&emsp;配置完成后回到Coding，在静态网站中找到设置，在 绑定新域名 处添加域名，如果你没有配置DNS是会提示申请证书失败的。另外由于网站是由Coding或Github托管的，所以不需要备案，正确配置CNAME即可。待证书状态显示 正常 就绑定成功了，用新域名访问博客吧！ CloudFlare域名解析&emsp;&emsp;上一步GoDaddy的DNS我们可以不用，可直接省略。使用CloudFlare解析域名，顺便蹭一蹭免费CDN。账号注册成功后，点击添加站点（会自动弹出），然后输入要使用的域名，之后CloudFlare会提供两个NS地址，要求在域名注册商那里修改NS地址。 &emsp;&emsp;回到GoDaddy，进入域名管理，修改域名服务器，把CloudFlare提供的两个NS地址粘贴进去，然后确认，之后会显示：我们无法显示您的DNS信息，因为您的域名服务器不是由我们管理的。 OK，没GoDaddy啥事儿了。 &emsp;&emsp; &emsp;&emsp;返回CloudFlare后点击检查名称服务器（忘了具体名称了，看页面提示就行），然后会提示在排队等待检查。修改DNS后需要等一会CloudFlare才有反应。 &emsp;&emsp;域名在CloudFlare这边添加成功后，点击域名进入域名管理界面，找到 DNS 配置CNAME。其中小云朵标志代表开启CDN加速，如果你网站的主要访客来自境外，那么建议开启，橙色代表开启。国内的话就关闭吧，速度比Github还慢。所以这个CDN加速与国内无缘，关掉后只使用域名解析。（我郑州联通，ping GithubPages的地址只有100ms出头的延迟，走CDN居然飙到将近300ms？？CloudFlare对国内真的不友好） &emsp;&emsp;Coding和Github都有免费提供SSL证书的，自定义域名后直接在设置页面开启 强制HTTPS 就好，Github在自定义域名后会自动申请证书。此外也可以找CloudFlare申请证书。域名管理页面找到 SSL/TLS，确认SSL/TLS加密模式为完全，一般默认就是。 &emsp;&emsp; &emsp;&emsp;之后在 边缘证书 栏目找到 始终使用HTTPS，确认该项为开启状态。之后就慢慢等吧，CloudFlare会在24小时内为域名颁发证书。 &emsp;&emsp; 阿里云域名解析&emsp;&emsp;为了实现国内走Coding，国外走Github，可以选择用阿里云的DNS解析（腾讯云也差不多，都一样的东西）。流程跟CloudFlare一样，账号注册完成后，在主页找到控制台 -&gt; 域名 -&gt; 进入域名解析列表 -&gt; 添加域名，然后回到域名注册商，改成下面阿里云的两个DNS，稍等几分钟就OK了。 ns1.alidns.comns2.alidns.com &emsp;&emsp;域名添加成功后，为Github和Coding的博客分别添加CNAME记录，默认解析到Coding，境外解析到Github。 &emsp;&emsp; 总结&emsp;&emsp;这一波折腾完觉得自己知识面真的太窄，一开始想贪CloudFlare的免费CDN，就去用他的DNS解析，结果是反向加速，GithubPages被闲置，域名只解析到CodingPages。用国内的CDN是需要备案的，想到CloudFlare的CDN是反向加速，也没什么好抱怨了（主要还是懒得备案）。 &emsp;&emsp;我还尝试了GiteePages，速度蛮快的，毕竟国内阿里云，Ping一下全国都深绿的，有条件的用Gitee托管效果应该不错。搭建流程跟GithubPages一样，项目名称使用用户名能开启 XXX.gitee.io的地址，否则地址末尾会包含项目名。但是Gitee很抠，升级pro版才能自定义域名和自动部署，而且普通版每次发布后还要手动更新。Pro版每年99元，新用户有1个月的免费体验，我试了下，配置证书的时候出了问题，Gitee要求粘贴域名证书和密钥，没整成（可能是我太笨），如果你搞定了一定要告诉我，不胜感激！ &emsp;&emsp;CodingPages用的新加坡的腾讯云，延迟和加载速度肯定比不了Gitee，但比直接GithubPages肯定强多了，ping一下我觉得延迟还行吧，郑州联通大概80+的延迟，具体分时段，加载速度还算能接受。具体如何选择还是看个人吧。 &emsp;&emsp;PS：每次Hexo发布会自动覆盖CNAME文件，如果是直接在Github仓库加的CNAME文件，每次发布后自定义域名会失效，解决办法是把CNAME文件放入Hexo的source文件夹。 unsplash-logoPolina Rytova","link":"/2020/04/27/coding-pages-n-custom-domain/"},{"title":"N皇后（N-Queens）","text":"LeetCode 51 N-Queens LeetCode 52 N-Queens II Lanqiao BASIC-27 2N-Queens Lanqiao ADV-203 8-Queens PAT-A 1128 N-Queens Puzzle N-Queens Description &emsp;&emsp;n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 &emsp;&emsp; &emsp;&emsp;上图为 8 皇后问题的一种解法。 &emsp;&emsp;给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。 &emsp;&emsp;每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。 &emsp;&emsp;原题：LeetCode 51 N-Queens Sample 123456789101112131415输入: 4输出: [ [&quot;.Q..&quot;, // 解法 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, // 解法 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;]]解释: 4 皇后问题存在两个不同的解法。 Thought &emsp;&emsp;题目要求将n个皇后放置在n * n大小的棋盘上，皇后之间不能打架，也就是每行、每列、每条对角线上不能同时有两位皇后。 &emsp;&emsp;思路就是深搜回溯，从第1行开始每次逐列放置皇后，每次放置时对已经放置完成的行进行判断，能放则放，不能放则弃。也就是检查当前位置皇后的上、左上、右上方是否存在皇后。完成n个皇后放置任务后将当前棋盘添加至结果集。 Code 1 &emsp;&emsp;觉得这题难度其实不大，就是个人在效率上有点难受（再见残酷的世界！），第1版写完交上去虽然一次AC了，但时间和空间居然都被95%的人碾压？？？（拐回来看代码发现参数全是形参，改了引用参数后时间击败60%空间击败100%）然后参考老哥们的题解改了改，还凑合吧，粘两个版本留念。 &emsp;&emsp;直接把整个棋盘开出来了，然后逐行放置皇后。检查已放置的行就开了3个for循环，分别对正上、左上、右上的格子进行遍历判断。 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution {public: bool isValid(vector&lt;string&gt;&amp; bd, int row, int col) { //正上 for(int i = 0; i &lt; row; i++) { if(bd[i][col] == 'Q') return false; } //左上 for(int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--) { if(bd[i][j] == 'Q') return false; } //右上 for(int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; bd.size(); i--, j++) { if(bd[i][j] == 'Q') return false; } return true; } void dfs(vector&lt;string&gt;&amp; bd, int row, int n) { if(row == n) { res.push_back(bd); return; } for(int i = 0; i &lt; n; i++) { if(isValid(bd, row, i)) { bd[row][i] = 'Q'; dfs(bd, row + 1, n); bd[row][i] = '.'; } } } vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) { vector&lt;string&gt; bd(n, string(n, '.')); dfs(bd, 0, n); return res; }private: vector&lt;vector&lt;string&gt;&gt; res;}; Code 2 &emsp;&emsp;棋盘是按行开辟的，凑够一整盘后带走放入结果集（空间上没有影响，就是单纯尝试下。。。） &emsp;&emsp;这个判断比较有意思，是在题解区学的。先开个数组用来存放棋盘每一行放置皇后的列值，在判断时，如果当前列与数组中的列重复，即正上方有皇后。对角线点坐标的x, y与当前点相减的绝对值是相同的，由此判断对角线上是否存在皇后。 123456789101112131415161718192021222324252627282930313233343536373839class Solution {public: bool isValid(int row, int col, vector&lt;int&gt; &amp;pos) { for (int i = 0; i &lt; row; i++) { if (col == pos[i] || abs(row - i) == abs(pos[i] - col)) return false; } return true; } void dfs(int row, int n, vector&lt;int&gt; &amp;pos, string &amp;line) { if (row == n) { res.push_back(tmp); return; } for (int i = 0; i &lt; n; i++) { if (isValid(row, i, pos)) { line[i] = 'Q'; tmp.push_back(line); line[i] = '.'; pos[row] = i; dfs(row + 1, n, pos, line); pos[row] = -1; tmp.pop_back(); } } } vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) { string line(n, '.'); vector&lt;int&gt; pos(n, -1); dfs(0, n, pos, line); return res; }private: vector&lt;vector&lt;string&gt;&gt; res; vector&lt;string&gt; tmp;}; N-Queen II Description &emsp;&emsp;n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 &emsp;&emsp;&emsp;&emsp; &emsp;&emsp;上图为 8 皇后问题的一种解法。 &emsp;&emsp;给定一个整数 n，返回 n 皇后不同的解决方案的数量。 &emsp;&emsp;原题：LeetCode 52 N-Queens II Sample 12345678910111213141516输入: 4输出: 2解释: 4 皇后问题存在如下两个不同的解法。[ [&quot;.Q..&quot;, // 解法 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, // 解法 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;]] Thought &emsp;&emsp;怎么说呢，我严重怀疑LeetCode的临时工把题号标错了，这个虽然是II，但明显是原版的简化。看见题就没多想，直接复制粘贴上一题代码，删掉所有棋盘数据，只保留存放每行皇后位置的数组，跑都没跑就提交了（也就这时候敢浪）。在题解区看到用位运算好像效率蛮高的，改（有）天（缘）再看吧。 Code 12345678910111213141516171819202122232425262728293031class Solution {public: bool isValid(int row, int col, vector&lt;int&gt; &amp;pos) { for (int i = 0; i &lt; row; i++) { if (col == pos[i] || abs(row - i) == abs(pos[i] - col)) return false; } return true; } void dfs(int row, int n, vector&lt;int&gt; &amp;pos, int &amp;res) { if (row == n) { res++; return; } for (int i = 0; i &lt; n; i++) { if (isValid(row, i, pos)) { pos[row] = i; dfs(row + 1, n, pos, res); pos[row] = -1; } } } int totalNQueens(int n) { vector&lt;int&gt; pos(n, -1); int res = 0; dfs(0, n, pos, res); return res; }}; 2N-Queens Description &emsp;&emsp;给定一个n*n的棋盘，棋盘中有一些位置不能放皇后。现在要向棋盘中放入n个黑皇后和n个白皇后，使任意的两个黑皇后都不在同一行、同一列或同一条对角线上，任意的两个白皇后都不在同一行、同一列或同一条对角线上。问总共有多少种放法？n小于等于8。 Input: &emsp;&emsp;输入的第一行为一个整数n，表示棋盘的大小。 &emsp;&emsp;接下来n行，每行n个0或1的整数，如果一个整数为1，表示对应的位置可以放皇后，如果一个整数为0，表示对应的位置不可以放皇后。 Output: &emsp;&emsp;输出一个整数，表示总共有多少种放法。 Sample 12345678910111213141516171819输入: // Sample 141 1 1 11 1 1 11 1 1 11 1 1 1输出:2输入: // Sample 241 0 1 11 1 1 11 1 1 11 1 1 1输出:0 Thought &emsp;&emsp;和N皇后的思路一样，区别是放置两种颜色的皇后，也就是黑白皇后各来一次深搜。根据题意，棋盘上1代表可以放置，0代表不可放置。用2表示白皇后，用3表示黑皇后。放置白皇后时遇到0跳过，放置黑皇后时遇到0和2跳过，两种颜色全部放完时（q == 4)结束并计数。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;int n, bd[10][10], res = 0;bool isValid(int row, int col, int q) { // q 为皇后类型 for (int r = row - 1, t = 1; r &gt;= 0; r--, t++ ) { if (bd[r][col] == q || (col - t &gt;= 0 &amp;&amp; bd[r][col - t] == q) || (col + t &lt; n &amp;&amp; bd[r][col + t] == q)) { return false; } } return true;}void dfs(int row, int q) { if (q == 4) { // 黑白皇后均已放完 res++; return; } else if (row == n) { dfs(0, q + 1); // 放置另一种颜色的皇后 return; } for (int col = 0; col &lt; n; col++) { if (bd[row][col] == 0 || bd[row][col] == 2) continue; if (isValid(row, col, q)) { bd[row][col] = q; dfs(row + 1, q); bd[row][col] = 1; } }}int main() { scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) scanf(\"%d\", &amp;bd[i][j]); dfs(0, 2); cout &lt;&lt; res &lt;&lt; endl;} 8-Queens Description &emsp;&emsp;规则同8皇后问题，但是棋盘上每格都有一个数字，要求八皇后所在格子数字之和最大。 Input: &emsp;&emsp;一个8*8的棋盘。 Ouput: &emsp;&emsp;所能得到的最大数字和 Sample 1234567891011121314输入:1 2 3 4 5 6 7 89 10 11 12 13 14 15 1617 18 19 20 21 22 23 2425 26 27 28 29 30 31 3233 34 35 36 37 38 39 4041 42 43 44 45 46 47 4848 50 51 52 53 54 55 5657 58 59 60 61 62 63 64输出:260数据规模和约定: 棋盘上的数字范围 0~99 Thought &emsp;&emsp;依然是深搜回溯，各个位置的数字已经给了，并且题目说明了数字范围为0~99，所以我们将访问的数字累加，并将值改为-1表示已经访问过，确保不被重复访问。每次满足终止条件时，比较当前放置方法的数字之和，取最大值即可。 Code 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;int n = 8, bd[10][10], res = 0;bool isValid(int row, int col) { for (int r = row - 1, t = 1; r &gt;= 0; r--, t++ ) { if (bd[r][col] == -1 || (col - t &gt;= 0 &amp;&amp; bd[r][col - t] == -1) || (col + t &lt; n &amp;&amp; bd[r][col + t] == -1)) { return false; } } return true;}void dfs(int row, int sum) { if (row == n) { res = max(res, sum); return; } for (int col = 0; col &lt; n; col++) { if (isValid(row, col)) { int tmp = bd[row][col]; bd[row][col] = -1; dfs(row + 1, sum + tmp); bd[row][col] = tmp; } }}int main() { for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) scanf(\"%d\", &amp;bd[i][j]); dfs(0, 0); cout &lt;&lt; res &lt;&lt; endl;} N Queens Puzzle Description The “eight queens puzzle” is the problem of placing eight chess queens on an 8 × 8 chessboard so that no two queens threaten each other. Thus, a solution requires that no two queens share the same row, column, or diagonal. The eight queens puzzle is an example of the more general N queens problem of placing N non-attacking queens on an N×N chessboard. (From Wikipedia - “Eight queens puzzle”.) Here you are NOT asked to solve the puzzles. Instead, you are supposed to judge whether or not a given configuration of the chessboard is a solution. To simplify the representation of a chessboard, let us assume that no two queens will be placed in the same column. Then a configuration can be represented by a simple integer sequence (Q​1, Q2, ⋯, Q​N), where Qi is the row number of the queen in the i-th column. For example, Figure 1 can be represented by (4, 6, 8, 2, 7, 1, 3, 5) and it is indeed a solution to the 8 queens puzzle; while Figure 2 can be represented by (4, 6, 7, 2, 8, 1, 9, 5, 3) and is NOT a 9 queens’ solution. Figure 1 Figure 2 Input Specification Each input file contains several test cases. The first line gives an integer K (1&lt;K≤200). Then K lines follow, each gives a configuration in the format “N Q1 Q2 … QN”, where 4≤N≤1000 and it is guaranteed that 1≤Qi≤N for all i=1,⋯,N. The numbers are separated by spaces. Output Specification For each configuration, if it is a solution to the N queens problem, print YES in a line; or NO if not. Sample Input 1234548 4 6 8 2 7 1 3 59 4 6 7 2 8 1 9 5 36 1 5 2 6 4 35 1 3 5 2 4 Sample Output 1234YESNONOYES 原题：PAT-A N Queens Puzzle Thought 直接暴力就Vans了，为了方便思考将棋盘顺时针反转90度。输入的过程理解成逐行放置皇后的过程。以Figure 1为例，输入皇后位置分别为第1行第4列，第2行第6列… 每输入一个数字（每放置一个皇后）就遍历之前的所有行，检查是否有同列或者同对角线的。 Code 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(0); int K; cin &gt;&gt; K; while(K--) { int N, t, flag = 1; cin &gt;&gt; N; vector&lt;int&gt; vec; for (int i = 0; i &lt; N; i++) { cin &gt;&gt; t; vec.push_back(t); int l = t - 1, r = t + 1; for (int j = i - 1; j &gt;= 0 &amp;&amp; flag; j--) { if (vec[j] == t || vec[j] == l || vec[j] == r) { flag = 0; } l--, r++; } } cout &lt;&lt; (flag ? \"YES\" : \"NO\") &lt;&lt; endl; }} Summary&emsp;&emsp;总得来说就是简单的暴力深搜回溯，逻辑上没什么细节好抠的。虽然LeetCode标记的难度是Hard，但实际其实还好？不过第一次信心满满地交上去，结果时间和空间都只击败5%真的难受（弱鸡枯了），确实自己经常粗心忘打取地址符，导致内存使用翻倍，尤其是变量名很长的时候都是习惯性复制粘贴，就忘了。 &emsp;&emsp;蓝桥的比LeetCode难度稍大，比较有意思的是蓝桥的2N皇后被放在“基础练习”的试题集，而相较而言更简单的8皇后被放在“算法提高”？？？可能跟LeetCode是同一个临时工吧哈哈哈哈。 unsplash-logoMichał Parzuchowski","link":"/2020/04/08/n-queens/"}],"tags":[{"name":"PicGo","slug":"PicGo","link":"/tags/PicGo/"},{"name":"jsDelivr","slug":"jsDelivr","link":"/tags/jsDelivr/"},{"name":"Travis CI","slug":"Travis-CI","link":"/tags/Travis-CI/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"BnB","slug":"BnB","link":"/tags/BnB/"},{"name":"PAT","slug":"PAT","link":"/tags/PAT/"},{"name":"Dijkstra","slug":"Dijkstra","link":"/tags/Dijkstra/"},{"name":"Graph","slug":"Graph","link":"/tags/Graph/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"BackTracking","slug":"BackTracking","link":"/tags/BackTracking/"}],"categories":[{"name":"Tech","slug":"Tech","link":"/categories/Tech/"},{"name":"Note","slug":"Note","link":"/categories/Note/"},{"name":"Diary","slug":"Diary","link":"/categories/Diary/"},{"name":"Blog","slug":"Tech/Blog","link":"/categories/Tech/Blog/"},{"name":"Problem","slug":"Note/Problem","link":"/categories/Note/Problem/"},{"name":"Design Pattern","slug":"Note/Design-Pattern","link":"/categories/Note/Design-Pattern/"}]}